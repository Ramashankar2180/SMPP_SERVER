accesslog.c:	szStr = gw_malloc(iBytesToBeCrtd + 1);
accesslog.c:	szTemp = gw_malloc(iBytesToBeCrtd + 1);
accesslog.c:	szTemp = gw_malloc((iBytesToBeAloctd+1));
accesslog.c:    szTemp1 = gw_malloc((iBytesToBeAloctd+1));
accesslog.c:    szTemp2 = gw_malloc((iBytesToBeAloctd+1));
accesslog.c:    szTemp3 = gw_malloc((iBytesToBeAloctd+1));
accesslog.c:    szTempStr = gw_malloc((iBytesToBeAloctd+1));
accesslog.c:    szFileName = gw_malloc((iBytesToBeAloctd+1));
cfg.c:    grp = gw_malloc(sizeof(*grp));
cfg.c:    cfgloc = gw_malloc(sizeof(*cfgloc)); 
cfg.c:    cfg = gw_malloc(sizeof(*cfg));
charset.c:    pointer = to_buf = gw_malloc(outbytes + 1);
conn.c:    conn = gw_malloc(sizeof(*conn));
conn.c:    ssl_static_locks = gw_malloc(sizeof(Mutex *) * maxlocks);
counter.c:    counter = gw_malloc(sizeof(Counter));
dbpool.c:    p = gw_malloc(sizeof(DBPool));
dbpool.c:            DBPoolConn *pc = gw_malloc(sizeof(DBPoolConn));
dbpool_mysql.c:    mysql = gw_malloc(sizeof(MYSQL));
dbpool_oracle.c:    void *ret = gw_malloc(size);
dbpool_oracle.c:    struct ora_conn *conn = gw_malloc(sizeof(struct ora_conn));
dbpool_oracle.c:    data = gw_malloc(sizeof(struct data_s)*columns);
dbpool_oracle.c:        data[i].data = gw_malloc(data[i].size);
dict.c:    item = gw_malloc(sizeof(*item));
dict.c:    dict = gw_malloc(sizeof(*dict));
dict.c:    dict->tab = gw_malloc(sizeof(dict->tab[0]) * dict->size);
fdset.c:    new = gw_malloc(sizeof(*new));
fdset.c:    new = gw_malloc(sizeof(*new));
fdset.c:    new->pollinfo = gw_malloc(sizeof(new->pollinfo[0]) * new->size);
fdset.c:    new->callbacks = gw_malloc(sizeof(new->callbacks[0]) * new->size);
fdset.c:    new->datafields = gw_malloc(sizeof(new->datafields[0]) * new->size);
fdset.c:    new->times = gw_malloc(sizeof(new->times[0]) * new->size);
gwmem-check.c: * call would try to allocate memory with gw_malloc before we're
gwmem.h:#define gw_malloc(size) (gw_native_malloc(size))
gwmem.h:#define gw_malloc_trace(size, file, line, func) (gw_native_malloc(size))
gwmem.h:#define gw_malloc_trace(size, file, line, func) \
gwmem.h:#define gw_malloc(size) \
gw-prioqueue.c:    ret = gw_malloc(sizeof(*ret));
gw-rwlock.c:    RWLock *ret = gw_malloc(sizeof(*ret));
gwthread-pthread.c:    p = gw_malloc(sizeof(*p));
gwthread-pthread.c:    p->ti = gw_malloc(sizeof(*(p->ti)));
gwthread-pthread.c:    pollfds = gw_malloc((numfds + 1) * sizeof(*pollfds));
http.c:    ent = gw_malloc(sizeof(*ent));
http.c:    trans = gw_malloc(sizeof(*trans));
http.c:    p = gw_malloc(sizeof(HTTPURLParse));
http.c:    p = gw_malloc(sizeof(*p));
http.c:        p = gw_malloc(sizeof(*p));
http.c:    p = gw_malloc(sizeof(*p));
http.c:    p = gw_malloc(sizeof(*p));
http.c:        v = gw_malloc(sizeof(HTTPCGIVar));
list.c:    list = gw_malloc(sizeof(List));
log.c:	szStr = gw_malloc((iBytesToBeCrtd + 1));
log.c:	szTemp = gw_malloc((iBytesToBeCrtd + 1));
log.c:    szFileName = gw_malloc((iBytesToBeCrtd + 1));
log.c:	szTemp = gw_malloc((iBytesToBeCrtd + 1));
log.c:    szTemp1 = gw_malloc((iBytesToBeCrtd + 1));
log.c:    szTemp2 = gw_malloc((iBytesToBeCrtd + 1));
log.c:    szTemp3 = gw_malloc((iBytesToBeCrtd + 1));
log.c:    szTempStr = gw_malloc((iBytesToBeCrtd + 1));
mime.c:    e = gw_malloc(sizeof(MIMEEntity));
msgq.c:			db_insert_ptr = gw_malloc(sizeof(struct db_insert));
msgq.c:			db_extract_ptr = gw_malloc(sizeof(struct db_extract_values));
msgq.c:			db_extracted_ptr = gw_malloc(sizeof(struct db_extracted_values));
msgq.c:			db_extract_ptr = gw_malloc(sizeof(struct db_extract_values));
msgq.c:			data_on_q = gw_malloc(sizeof(struct mis_insert));
msgq.c:			data_on_q = gw_malloc(sizeof(struct mis_update));
octstr.c:    ostr = gw_malloc_trace(sizeof(*ostr), file, line, func);
octstr.c:        ostr->data = gw_malloc_trace(ostr->size, file, line, func);
octstr.c:	os = gw_malloc(sizeof(*os));
octstr.c:    ostr->data = gw_malloc(ostr->size);
octstr.c:    res = str2 = (n ? gw_malloc((len = ostr->len + 2 * n + 1)) : ostr->data);
octstr.c:    ostr->data = gw_malloc(ostr->size);
octstr.c:    return_ostr->data = gw_malloc(return_ostr->size);
octstr.c:    return_ostr->data = gw_malloc(return_ostr->size);
octstr.c:    return_ostr->data = gw_malloc(return_ostr->size);
octstr.c:    return_ostr->data = gw_malloc(return_ostr->size);
octstr.c:    return_ostr->data = gw_malloc(return_ostr->size);
octstr.c:    return_ostr->data = gw_malloc(return_ostr->size);
octstr.c.debug:    ostr = gw_malloc(sizeof(*ostr));
octstr.c.debug:        ostr->data = gw_malloc(ostr->size);
octstr.c.debug:	os = gw_malloc(sizeof(*os));
octstr.c.debug:    ostr->data = gw_malloc(ostr->size);
octstr.c.debug:    res->data = gw_malloc(res->size);
octstr.h: * all functions use gw_malloc and friends, so they won't return if the
octstr.h.debug: * all functions use gw_malloc and friends, so they won't return if the
parse.c:    result = gw_malloc(sizeof(*result));
parse.c:    elem = gw_malloc(sizeof(*elem));
process_sock.c:    msg = gw_malloc_trace(sizeof(Conn_Msg), file, line, func);
process_sock.c:	process_client = gw_malloc(sizeof(PROCESS_CLIENT));
process_sock.c:	start_server = gw_malloc(sizeof(START_SERVER));
process_sock.c:	start_client 				= gw_malloc(sizeof(START_CLIENT));
process_sock.c:	server_data = gw_malloc(sizeof(SERVER_DATA));
protected.c:    *buff = (char*) gw_malloc(bufflen);
protected.c:    *buff = gw_malloc(bufflen);
protected.c:    bufptr = *buff = gw_malloc(bufflen);
regex.c:    preg = gw_malloc(sizeof(regex_t));
regex.c:    res = gw_malloc(len);
regex.c:    dest = dst = gw_malloc(len + 1);
semaphore.c:    semaphore = gw_malloc(sizeof(*semaphore));
smpp_pdu.c:	pdu = gw_malloc(sizeof(*pdu));
socket.c:    buf = gw_malloc(UDP_PACKET_MAX_SIZE);
thread.c:    mutex = gw_malloc(sizeof(Mutex));
xmlrpc.c:    XMLRPCMethodCall *nmsg = gw_malloc(sizeof(XMLRPCMethodCall));
xmlrpc.c:    XMLRPCFault *fault = gw_malloc(sizeof(XMLRPCFault));
xmlrpc.c:    XMLRPCMethodResponse *nmsg = gw_malloc(sizeof(XMLRPCMethodResponse));
xmlrpc.c:    XMLRPCDocument *xrdoc = gw_malloc(sizeof(XMLRPCDocument));
xmlrpc.c:    XMLRPCValue *val = gw_malloc(sizeof(XMLRPCValue));
xmlrpc.c:    XMLRPCScalar *scalar = gw_malloc(sizeof(XMLRPCScalar));
xmlrpc.c:    XMLRPCMember *member = gw_malloc(sizeof(XMLRPCMember));
