/* ==================================================================== 
 *  
 *
 * server.c - SMPP server 
 *
 * 
 ==================================================================== */

#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>

#include "gwlib/gwlib.h"
#include "gwlib/smpp_pdu.h"
#include "esme.h"
#include "version.h"
#include "httpadmin.h"
#include "gwlib/process_sock.h"
#include <sys/timeb.h>
#define TIME_CALCULATE 1

static int quitting = 0;
static Octstr *bearerbox_host;
static Octstr *smsc_system_id;
static Octstr *smsc_source_addr;

static int port_for_smsbox;
static Counter *num_to_esme;
static long max_to_esme;

static time_t process_start_time;
static time_t start_time = (time_t) -1;
static time_t first_to_esme = (time_t) -1;
static time_t last_to_esme = (time_t) -1;
static time_t last_from_esme = (time_t) -1;
static time_t first_from_bb = (time_t) -1;
static time_t last_to_bb = (time_t) -1;
static long enquire_interval = 1; /* Measured in messages, not time. */

static Counter *num_from_bearerbox;
static Counter *num_to_bearerbox;
static Counter *num_from_esme;
/*counter for storing the seq numbers sent by the server
  will be used mainly in case of sending deliver_sm*/
static Counter *seq_number_counter;

/*counter for storing the smsc msg id as generated by the server*/
static Counter *message_id_counter;

static Smsc_Client_List *translations = NULL;/*stores the smpp-client- list as read by config file*/

static Cfg *cfg;

/*various port numbers - need not be protected as is written only once.*/
long trans_port;
long recv_port;
long trans_recv_port;
int dndcheck_flag=0;
/*storing the status of the program*/
volatile sig_atomic_t program_status;

static Octstr *config_filename;
static Octstr *logfile;
long log_file_index;
Octstr *access_file_name = NULL;
volatile enum process_program_status process_program_status = starting_up;
PROCESS_CLIENT *dbbox_client;
PROCESS_CLIENT *forward_client;
PROCESS_CLIENT *reverse_client;
long smsc_q_limit = -1;
Dict *pending_deliver_sm;
int dbbox_connected_to_client = -1;
int global_q_limit = -1;

int giManagelogInterval;
//[sanchal][170309][to store the interval of log checking sizewise as well as day wise]
long giLogSize;
//[sanchal][050109][to store size of log read from conffile]

/*called by signald handler to terminate all the listening threads -- so that they can be terminated*/
static void quit(void)
{
	quitting = 1;
	program_status = PROGRAM_DEAD;
	gwthread_wakeup_all();
}
/*used during binds to check various server connections
  return -1 if any one of the server is not connected else return 0*/
int check_server_connections(void)
{

	/*for testing dbbox is 
	  dbbox_connected_to_client = 1;
	  dbbox_client->status = PROCESS_CONNECTED;
	  for testing*/
	if(	dbbox_client == NULL 	|| 
			forward_client == NULL 	|| 
			reverse_client == NULL	||
			dbbox_connected_to_client != 1
	  )
		return -1;
	if(	dbbox_client->status != PROCESS_CONNECTED  || 
			forward_client->status != PROCESS_CONNECTED || 
			reverse_client->status != PROCESS_CONNECTED)
		return -1;
	return 0;
}
void send_msg_dbbox_server(Conn_Msg *msg,int mode)
{
	if((mode == 0) && (dbbox_client != NULL))
		send_msg_process_client(dbbox_client,msg);
	else
	{
		if(conn_msg_type(msg)==smpp_esme)
		{
			if(msg->smpp_esme.esm_class & ESM_CLASS_SUBMIT_UDH_INDICATOR)
				binary_msg_to_ascii(msg->smpp_esme.msg_content,&(msg->smpp_esme.udh),&(msg->smpp_esme.msg_content));

			warning(0,	"SHUT/DIS SMPP-ESME MSGS[ESMEAccName:%s][ESMEAccMsgId:%s]"
					"[SourceAddr:%s][DestinationAddr:%s][RecvTime:%s][SubmittedStat:%d]"
					"[UDH:%s][Content:%s][RetryValue:%d]",
					octstr_get_cstr(msg->smpp_esme.account_name),
					octstr_get_cstr(msg->smpp_esme.account_msg_id),
					octstr_get_cstr(msg->smpp_esme.source_addr),
					octstr_get_cstr(msg->smpp_esme.dest_addr),
					octstr_get_cstr(msg->smpp_esme.req_time),
					msg->smpp_esme.submit_status,
					msg->smpp_esme.udh ? octstr_get_cstr(msg->smpp_esme.udh):"",
					octstr_get_cstr(msg->smpp_esme.msg_content),
					msg->smpp_esme.retry_value
			       );
		}
		else if(conn_msg_type(msg)==insert_mis)
		{
			if(msg->insert_mis.esm_class & ESM_CLASS_SUBMIT_UDH_INDICATOR)
				binary_msg_to_ascii(msg->insert_mis.msg_content,&(msg->insert_mis.udh),&(msg->insert_mis.msg_content));
			warning(0,	"SHUT/DIS MIS INSERT MSGS [ESMEAccName:%s][ESMEAccMsgId:%s]"
					"[SourceAddr:%s][DestinationAddr:%s]"
					"[RecvTime:%s][SubmittedStat:%d][RetryValue:%d]"
					"[UDH:%s][Content:%s]",
					octstr_get_cstr(msg->insert_mis.account_name),
					octstr_get_cstr(msg->insert_mis.account_msg_id),
					octstr_get_cstr(msg->insert_mis.source_addr),
					octstr_get_cstr(msg->insert_mis.dest_addr),
					octstr_get_cstr(msg->insert_mis.req_time),
					msg->insert_mis.submit_status,
					msg->insert_mis.retry_value,
					msg->insert_mis.udh ? octstr_get_cstr(msg->insert_mis.udh):"",
					octstr_get_cstr(msg->insert_mis.msg_content)
			       );
		}
	}
}
int mis_db_insert(	Octstr *account_name,
		Octstr *account_msg_id,
		SMPP_PDU *pdu,
		long submit_status , Octstr *IP
		)
{

	Conn_Msg *msg;
	msg = conn_msg_create(insert_mis);
	msg->insert_mis.account_name = octstr_duplicate(account_name);
	msg->insert_mis.account_msg_id = octstr_duplicate(account_msg_id);
	msg->insert_mis.smsc_id = octstr_create("");
	msg->insert_mis.smsc_msg_id = octstr_create("");
	msg->insert_mis.req_time =    get_current_datetime();
	msg->insert_mis.source_addr = octstr_duplicate(pdu->u.submit_sm.source_addr);
	msg->insert_mis.dest_addr = octstr_duplicate(pdu->u.submit_sm.destination_addr);
	msg->insert_mis.submit_status = submit_status;
	msg->insert_mis.esm_class = pdu->u.submit_sm.esm_class;
	msg->insert_mis.message_len = octstr_len(pdu->u.submit_sm.short_message);
	msg->insert_mis.msg_content = octstr_duplicate(pdu->u.submit_sm.short_message);
	if(pdu->u.submit_sm.user_response_code != -1)
		msg->insert_mis.retry_value = pdu->u.submit_sm.user_response_code;
	else
		msg->insert_mis.retry_value = 0;
	msg->insert_mis.IP = octstr_duplicate(IP);

	info("\n\n----------IP***************Rama  : %s :%s ",octstr_get_cstr( msg->insert_mis.IP),octstr_get_cstr(IP));
	//send_msg_process_client(dbbox_client,msg);
	send_msg_dbbox_server(msg,0);
}
/*called by system thread when receives shutdown command from client*/
static void signal_handler(int signum);

//[201108] [Changed as bind is handled seperately]
//	   [ msg_bindinfo contains Tx/Rx/TRx/TxRx and SMPP_PDU structures ]	
//static SMPP_PDU *handle_bind_transmitter(ESME *esme, SMPP_PDU *pdu)
static MSG_BIND_INFO *handle_bind_transmitter(TEMPCONN *temp_conn, SMPP_PDU *pdu)
{
	MSG_BIND_INFO *msgresp_ptr;	
	msgresp_ptr = gw_malloc(sizeof(MSG_BIND_INFO));
	msgresp_ptr->resp = NULL;
	msgresp_ptr->esme = NULL;

	int ret;
	int mode = -1;

	msgresp_ptr->resp = smpp_pdu_create(bind_transmitter_resp,pdu->u.bind_transmitter.sequence_number);
	info(0,"Bind transmitter result for Client[%s]:IP[%s]",
			octstr_get_cstr(pdu->u.bind_transmitter.system_id),
			octstr_get_cstr(temp_conn->client_ip));
	if(program_status != PROGRAM_RUNNING)
	{
		error(0, "Bind Transmitter received when system shutting down");
		msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
	}
	/*first check if request has arrived form the correct port*/
	else if(temp_conn->listen_port != trans_port)
	{
		info(0, "Bind Transmitter received from incorrect port");
		msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
	}
	else if(check_server_connections() == -1)
	{
		info(0, "One of the server is not connected Forward :%d Reverse :%d Dbbox :%d clientdbbox:%d",
				forward_client ? forward_client->status:-1,
				reverse_client ? reverse_client->status:-1,
				dbbox_client ? dbbox_client->status:-1,
				dbbox_connected_to_client);
		msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
	}
	else
	{
		mode = 1;
		ret = authorise_user(pdu,
				mode,
				translations,
				temp_conn,
				&(msgresp_ptr->esme));

		/*debug statements
		  if(msgresp_ptr->esme == NULL)
		////printf("\nESME IS NULL\n");
		else
		////printf("\nESME IS NOT NULL:%s\n",octstr_get_cstr(msgresp_ptr->esme->system_id));

		if(msgresp_ptr->esme != NULL)
		{
		if(msgresp_ptr->esme->esmetx == NULL)
		////printf("\nESME tx IS NULL\n");			
		else
		////printf("\nESME tx IS NOT NULL\n");			
		}
		/*debug statements*/

		if((ret == 0) && msgresp_ptr->esme != NULL && gwlist_len(msgresp_ptr->esme->tx_esme) > 0)
			temp_conn->bind_successful = 1;
		else
			temp_conn->bind_successful = 0;

		info(0, "AUTHORISE USER RETURN VALUE:%d",ret);
		if((ret == 0) && msgresp_ptr->esme != NULL && msgresp_ptr->esme->tx_esme != NULL)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = 0;
			info(0, "%s Successfully binded",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 1)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "%s Username doesnot exists in config file",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 2)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Invalid password for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 3)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Mode assigned to the user :%s is not tx",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 6)
		{
			/*
			   Octstr *new_id = NULL;
			   new_id = octstr_create("duplicate");
			   octstr_append(pdu->u.bind_transmitter.system_id,new_id);
			   octstr_destroy(new_id);
			   esme->system_id = octstr_duplicate(pdu->u.bind_transmitter.system_id);
			   add_esme(esme);
			   */
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Sever - ESME has already logged in id :%s ",octstr_get_cstr(pdu->u.bind_transmitter.system_id));

		}
		else if(ret == 4 || ret == 5)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Check for account start and expiry data for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 7)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "No SMSC present for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 8)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Connection denied from allowed/denied IP for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 9)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Double mode allowed failure :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 10)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Max tx sessions failure :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == -1)
		{
			msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Username is specified as NULL");
		}
	}

#if 1 /* XXX system_id is not implemented in the PDU at the moment */
	msgresp_ptr->resp->u.bind_transmitter_resp.system_id = octstr_duplicate(smsc_system_id);
	msgresp_ptr->resp->u.bind_transmitter_resp.sc_interface_version = SMPP_SERVER_VERSION;
#endif
	return msgresp_ptr;
}


//[201108] [Changed as bind is handled seperately]
//	   [ msg_bindinfo contains Tx/Rx/TRx/TxRx and SMPP_PDU structures ]	
//static SMPP_PDU *handle_bind_receiver(ESME *esme, SMPP_PDU *pdu)
static MSG_BIND_INFO *handle_bind_receiver(TEMPCONN *temp_conn, SMPP_PDU *pdu)
{
	MSG_BIND_INFO *msgresp_ptr;	
	msgresp_ptr = gw_malloc(sizeof(MSG_BIND_INFO));
	msgresp_ptr->resp = NULL;
	msgresp_ptr->esme = NULL;

	int ret;
	int mode = -1;



	msgresp_ptr->resp = smpp_pdu_create(bind_receiver_resp,
			pdu->u.bind_receiver.sequence_number);

	info(0,"Bind receiver result for Client[%s]:IP[%s]",octstr_get_cstr(pdu->u.bind_receiver.system_id),octstr_get_cstr(temp_conn->client_ip));
	if(program_status != PROGRAM_RUNNING)
	{
		info(0, "Bind receiver received when system shutting down");
		msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RBINDFAIL;
	}
	else if(temp_conn->listen_port != recv_port)
	{
		info(0, "Bind Received received from incorrect port");
		msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVCMDID;
	}
	else if(check_server_connections() == -1)
	{
		info(0, "One of the server is not connected Forward :%d Reverse :%d Dbbox :%d clientdbbox:%d",
				forward_client ? forward_client->status:-1,
				reverse_client ? reverse_client->status:-1,
				dbbox_client ? dbbox_client->status:-1,
				dbbox_connected_to_client);
		msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVCMDID;
	}
	else
	{
		mode = 2;
		ret = authorise_user(pdu,
				mode,
				translations,
				temp_conn,
				&(msgresp_ptr->esme));

		/*debug statements
		  if(msgresp_ptr->esme == NULL)
		////printf("\nESME IS NULL\n");
		else
		//printf("\nESME IS NOT NULL:%s\n",octstr_get_cstr(msgresp_ptr->esme->system_id));

		if(msgresp_ptr->esme != NULL)
		{
		if(msgresp_ptr->esme->esmerx == NULL)
		//printf("\nESME Rx IS NULL\n");			
		else
		//printf("\nESME Rx IS NOT NULL\n");			
		}
		/*debug statements*/
		if((ret == 0) && msgresp_ptr->esme != NULL && gwlist_len(msgresp_ptr->esme->rx_esme) > 0)
			temp_conn->bind_successful = 1;
		else
			temp_conn->bind_successful = 0;
		if(ret == 0)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = 0;
			info(0, "%s Successfully binded",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}

		else if(ret == 1)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVSYSID;
			info(0, "%s Username doesnot exists in config file",octstr_get_cstr(pdu->u.bind_receiver.system_id));
		}
		else if(ret == 2)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVPASWD;
			info(0, "Invalid password for user :%s",octstr_get_cstr(pdu->u.bind_receiver.system_id));
		}
		else if(ret == 3)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVCMDID;
			info(0, "Mode assigned to the user :%s is not rx",octstr_get_cstr(pdu->u.bind_receiver.system_id));
		}
		else if(ret == 6)
		{
			/*
			   Octstr *new_id = NULL;
			   new_id = octstr_create("duplicate");
			   octstr_append(pdu->u.bind_receiver.system_id,new_id);
			   octstr_destroy(new_id);
			   esme->system_id = octstr_duplicate(pdu->u.bind_receiver.system_id);
			   add_esme(esme);
			   */
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RALYNBD;
			info(0, "Sever - ESME has already logged in id :%s ",octstr_get_cstr(pdu->u.bind_receiver.system_id));

		}
		else if(ret == 4 || ret == 5)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVEXPIRY;
			info(0, "Check for account start and expiry data for user :%s ",octstr_get_cstr(pdu->u.bind_receiver.system_id));
		}

		else if(ret == 7)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVMSGID;
			info(0, "No SMSC present for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}

		else if(ret == 8)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVPRTFLG;
			info(0, "Connection denied from allowed/denied IP for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 9)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RINVPRTFLG;
			info(0, "Double mode allowed failure :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 10)
		{
			msgresp_ptr->resp->u.bind_receiver_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Max rx sessions failure :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
	}

#if 1 /* XXX system_id is not implemented in the PDU at the moment */
	msgresp_ptr->resp->u.bind_receiver_resp.system_id = octstr_duplicate(smsc_system_id);
	msgresp_ptr->resp->u.bind_receiver_resp.sc_interface_version = SMPP_SERVER_VERSION;
#endif
	return  msgresp_ptr;

}

//[201108] [Changed as bind is handled seperately]
//	   [ msg_bindinfo contains Tx/Rx/TRx/TxRx and SMPP_PDU structures ]	
//static SMPP_PDU *handle_bind_transceiver(ESME *esme, SMPP_PDU *pdu)
static MSG_BIND_INFO *handle_bind_transceiver(TEMPCONN *temp_conn, SMPP_PDU *pdu)
{
	MSG_BIND_INFO *msgresp_ptr;	
	msgresp_ptr = gw_malloc(sizeof(MSG_BIND_INFO));
	msgresp_ptr->resp = NULL;
	msgresp_ptr->esme = NULL;

	int ret;
	int mode = -1;
	msgresp_ptr->resp = smpp_pdu_create(bind_transceiver_resp,
			pdu->u.bind_transceiver.sequence_number);

	info(0,"Bind trx result for Client[%s]:IP[%s]",octstr_get_cstr(pdu->u.bind_transmitter.system_id),octstr_get_cstr(temp_conn->client_ip));
	if(program_status != PROGRAM_RUNNING)
	{
		info(0, "Bind transceiver received when system shutting down");
		msgresp_ptr->resp->u.bind_transmitter_resp.command_status = SMPP_ESME_RBINDFAIL;
	}
	else if(temp_conn->listen_port != trans_recv_port)
	{
		info(0, "Bind Transceiver received from incorrect port");
		msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVCMDID;
	}
	else if(check_server_connections() == -1)
	{
		info(0, "One of the server is not connected Forward :%d Reverse :%d Dbbox :%d clientdbbox :%d",
				forward_client ? forward_client->status:-1,
				reverse_client ? reverse_client->status:-1,
				dbbox_client ? dbbox_client->status:-1,
				dbbox_connected_to_client);
		msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVCMDID;


	}
	else
	{
		//printf("STEP 1\n");
		mode = 3;
		ret = authorise_user(pdu,
				mode,
				translations,
				temp_conn,
				&(msgresp_ptr->esme));

		/*debug statements
		  if(msgresp_ptr->esme == NULL)
		//printf("\nESME IS NULL\n");
		else
		//printf("\nESME IS NOT NULL:%s\n",octstr_get_cstr(msgresp_ptr->esme->system_id));

		if(msgresp_ptr->esme != NULL)
		{
		if(msgresp_ptr->esme->esmetx == NULL)
		//printf("\nESME tx IS NULL\n");			
		else
		//printf("\nESME tx IS NOT NULL\n");			
		}
		/*debug statements*/
		if((ret == 0) && msgresp_ptr->esme != NULL && gwlist_len(msgresp_ptr->esme->tx_esme) > 0)
			temp_conn->bind_successful = 1;
		else
			temp_conn->bind_successful = 0;
		if(ret == 0)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = 0;
			info(0, "%s Successfully binded",octstr_get_cstr(pdu->u.bind_transmitter.system_id));

		}
		else if(ret == 1)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVSYSID;
			info(0, "%s Username doesnot exists in config file",octstr_get_cstr(pdu->u.bind_transceiver.system_id));
		}
		else if(ret == 2)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVPASWD;
			info(0, "Invalid password for user :%s",octstr_get_cstr(pdu->u.bind_transceiver.system_id));
		}
		else if(ret == 3)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVCMDID;
			info(0, "Mode assigned to the user :%s is not txrx",octstr_get_cstr(pdu->u.bind_transceiver.system_id));
		}
		else if(ret == 6)
		{
			/*
			   Octstr *new_id = NULL;
			   new_id = octstr_create("duplicate");
			   octstr_append(pdu->u.bind_transceiver.system_id,new_id);
			   octstr_destroy(new_id);
			   esme->system_id = octstr_duplicate(pdu->u.bind_transceiver.system_id);
			   add_esme(esme);
			   */
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RALYNBD;
			info(0, "Sever - ESME has already logged in id:NOT NEW ID :%s ",octstr_get_cstr(pdu->u.bind_transceiver.system_id));
		}
		else if(ret == 4 || ret == 5)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVEXPIRY;
			info(0, "Check for account start and expiry data for user :%s ",octstr_get_cstr(pdu->u.bind_transceiver.system_id));
		}

		else if(ret == 7)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVMSGID;
			info(0, "No SMSC present for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}

		else if(ret == 8)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVPRTFLG;
			info(0, "Connection denied from allowed/denied IP for user :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 9)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RINVPRTFLG;
			info(0, "Double mode allowed failure :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
		else if(ret == 10)
		{
			msgresp_ptr->resp->u.bind_transceiver_resp.command_status = SMPP_ESME_RBINDFAIL;
			info(0, "Max trx sessions failure :%s",octstr_get_cstr(pdu->u.bind_transmitter.system_id));
		}
	}

#if 1 /* XXX system_id is not implemented in the PDU at the moment */
	msgresp_ptr->resp->u.bind_receiver_resp.system_id = octstr_duplicate(smsc_system_id);
	msgresp_ptr->resp->u.bind_receiver_resp.sc_interface_version = SMPP_SERVER_VERSION;
#endif
	return msgresp_ptr;
}

static SMPP_PDU *handle_submit_sm(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	struct forward_queue_data *fqd_ptr;
	SMPP_PDU *resp;
	unsigned long id;
	int ret;
	time_t start_t;
	Octstr *current_time;
	Conn_Msg *msg;
	long time_diff;
	struct tm *info1;	
	long reason;
	long timestamp;
	Octstr *os;
	Octstr *try = NULL;
	Octstr *dest_addr = NULL;
	Octstr *source_addr = NULL;	
	Octstr *data1 = NULL;
	Octstr *data2 = NULL;
	time(&start_t);
	info1 = localtime(&start_t);
	static long counter =0;

	id = counter_increase(num_from_esme) + 1;

	time(&last_from_esme);
	time(&start_t);

	time_diff = difftime(start_t,esme->esm_time);

#if 0
	if(time_diff>TIME_CALCULATE)
	{
		if((esme->msg_count/TIME_CALCULATE) > esme->max_tps)
		{ 
			int wait_count = 0 ;
			wait_count = esme->msg_count -  esme->max_tps*TIME_CALCULATE ;
			wait_count = wait_count/esme->max_tps + 1;
			info(0, "ESME has submitted more messgae [%d]than allocated TPS[%d] need to wait [%d] second.\n",esme->msg_count , esme->max_tps,wait_count);
			gwthread_sleep(wait_count);
		}
		info(0, "ESME has submitted time [%ld].[%d]",time_diff,esme->msg_count);
		time(&esme->esm_time);
		esme->msg_count = 0;
	}
#endif

	if(esme->msg_count > esme->max_tps)
	{
		time_diff = difftime(start_t,esme->esm_time);
		if(time_diff == 0)
		{

			info(0, "ESME has submitted more messgae [%d]than allocated TPS[%d] need to wait [%d] second with sleep.\n",esme->msg_count , esme->max_tps,time_diff);
			gwthread_sleep(1);

		}
		info(0, "ESME has submitted more messgae [%d]than allocated TPS[%d] need to wait [%d] without sleep second.\n",esme->msg_count , esme->max_tps,time_diff);
		time(&esme->esm_time);
		esme->msg_count = 0;

	}

	//	 if(esme->max_submits_unconnect < info1->tm_mon)
	//	{
	//			info(0, "ESME has submitted more messgae [%d]\n",esme->max_submits_unconnect);
	//			resp->u.submit_sm_resp.command_status = 0x00000404;
	//				printf("ESME has submitted more messgae [%s]\n",esme->max_submits_unconnect);
	//				check_smsc_api();
	//		}

	resp = smpp_pdu_create(submit_sm_resp, pdu->u.submit_sm.sequence_number);
	/*first handle RX related cos then we can type cast into TX */	
	if(mode == 2)
	{
		resp->u.submit_sm_resp.command_status = 0x00000400;
		time(&timestamp);
		resp->u.submit_sm_resp.message_id = octstr_format("%ld",timestamp);
		error(0, "Submit SM is received from a RX only port from CLIENT[%s]IP[%s]MODE[%d][SESSIONID:%d]",
				octstr_get_cstr(esme->system_id),
				octstr_get_cstr(((ESME_RX*)session_str)->client_ip),
				mode,
				session_id);
		goto ret;
	}
	/*Response ID is given even if the message is rejected*/
	//info(0, "ESME has submitted max *****************count [%d] time diff[%d]\n",counter_value(((ESME_TX*)session_str)->msg_received),time_diff);
	time(&timestamp);
	counter++;
	resp->u.submit_sm_resp.message_id = octstr_format("%ld%ld%ld", counter_value(((ESME_TX*)session_str)->msg_received),timestamp,counter);
	if(program_status != PROGRAM_RUNNING)
	{

		resp->u.submit_sm_resp.command_status = 0x00000407;
		error(0, "Submit SM is when system shutting down form CLIENT[%s]IP[%s]MODE[%d][SESSIONID:%d]",
				octstr_get_cstr(esme->system_id),
				octstr_get_cstr(((ESME_TX*)session_str)->client_ip),
				mode,
				session_id);
		counter_increase(((ESME_TX*)session_str)->msg_rejected);
		goto ret;
	}
	if(	reverse_client->status != PROCESS_CONNECTED || 
			forward_client->status != PROCESS_CONNECTED
	  )
	{
		if((smsc_q_limit != -1) && (gwlist_len(forward_client->send_list) == smsc_q_limit))
		{

			resp->u.submit_sm_resp.command_status = 0x00000409;
			error(0, "Submit SM is when SMSC Process is not connected CLIENT[%s]IP[%s]MODE[%d][SESSIONID:%d] Forward :%d,Reverse :%d",
					octstr_get_cstr(esme->system_id),
					octstr_get_cstr(((ESME_TX*)session_str)->client_ip),
					mode,
					session_id,
					forward_client->status,
					reverse_client->status);
			counter_increase(((ESME_TX*)session_str)->msg_rejected);
			goto ret;
		}
	}
	if(global_q_limit == 1)
	{
		resp->u.submit_sm_resp.command_status = 0x0000040A;
		error(0, "Submit SM when global is full CLIENT[%s]IP[%s]MODE[%d][SESSIONID:%d]",
				octstr_get_cstr(esme->system_id),
				octstr_get_cstr(((ESME_TX*)session_str)->client_ip),
				mode,
				session_id);
		counter_increase(((ESME_TX*)session_str)->msg_rejected);
		goto ret;
	}

	if(((ESME_TX*)session_str)->status == ESME_SMSC_UNCONNECTED)
	{
		if( esme->max_submits_unconnect != -1           &&
				max_submits_unct_account(esme,1)  >= esme->max_submits_unconnect)
		{
			warning(0,"MAX SUBMITS WITHOUT CONNECT EXCEDDED WILL REJECT MSG NOW :%ld",counter_value(((ESME_TX*)session_str)->submits_unconnect));
			resp->u.submit_sm_resp.command_status = SMPP_ESME_RMSGQFUL;
			counter_increase(((ESME_TX*)session_str)->msg_rejected);
			goto ret;
		}
		else
			counter_increase(((ESME_TX*)session_str)->submits_unconnect);
	}

	if(((ESME_TX*)session_str)->status == ESME_BINDED)
	{
		if( esme->max_submits != -1           &&
				counter_value(((ESME_TX*)session_str)->msg_received) >= esme->max_submits)
		{
			warning(0,"MAX SUBMITS  EXCEDDED WILL REJECT MSG NOW :%ld:%ld:%ld",counter_value(((ESME_TX*)session_str)->submits_unconnect),esme->max_submits,esme->max_submits_unconnect);
			resp->u.submit_sm_resp.command_status = SMPP_ESME_RMSGQFUL;
			counter_increase(((ESME_TX*)session_str)->msg_rejected);
			goto ret;
		}
		else
			counter_increase(((ESME_TX*)session_str)->submits_unconnect);
	}

	reason = verify_pdu_para(esme,pdu,&dest_addr,&source_addr);
	if((info1->tm_hour <= esme->valid_time_from) || ( info1->tm_hour >= esme->valid_time_to))
	{
		warning(0, "ESME Rejected due to time limit [%d][%d]\n",esme->valid_time_from,esme->valid_time_to);
		resp->u.submit_sm_resp.command_status = SMPP_ESME_RCANCELFAIL;
		counter_increase(((ESME_TX*)session_str)->msg_rejected);
		goto ret;
	}




	if(reason != SMPP_ESME_ROK)
	{
		resp->u.submit_sm_resp.command_status = reason;
		if(dest_addr != NULL)
			octstr_destroy(dest_addr);
		if(source_addr != NULL)
			octstr_destroy(source_addr);
		counter_increase(((ESME_TX*)session_str)->msg_rejected);
		goto ret;
	}
	msg = conn_msg_create(submit);

	ret = rout_pdu(translations,dest_addr,esme->system_id,&(msg->submit.preferred_smsc),&(msg->submit.allowed_smsc));

	if(ret == -1)
	{
		error(0, "[ESME%sMODE:%dSESSION:%d]: Submit SM not routable :%s ",
				octstr_get_cstr(esme->system_id),mode,session_id,octstr_get_cstr(dest_addr));
		//gw_free(fqd_ptr);
		conn_msg_destroy(msg);
		//octstr_destroy(os);
		octstr_destroy(dest_addr);
		octstr_destroy(source_addr);
		resp->u.submit_sm_resp.command_status = SMPP_ESME_RSUBMITFAIL;
		counter_increase(((ESME_TX*)session_str)->msg_rejected);
		goto ret;	
	}
	os = smpp_pdu_pack(pdu);
	current_time = get_current_datetime();
	msg->submit.req_time = current_time;
	msg->submit.account_name = octstr_duplicate(esme->system_id);
	msg->submit.account_msg_id = octstr_duplicate(resp->u.submit_sm_resp.message_id);
	msg->submit.destination_addr = dest_addr;
	msg->submit.source_addr = source_addr;
	msg->submit.pdu = os;
	msg->submit.IP = octstr_duplicate(((ESME_TX*)session_str)->client_ip);

	if(dndcheck_flag==0)
	{
		send_msg_process_client(forward_client,msg);
	}


	counter_increase(((ESME_TX*)session_str)->msg_sent);
	esme->msg_count ++;
ret:
	/*Insert into smpp esme table irrespective of status*/
	msg = conn_msg_create(smpp_esme);
	msg->smpp_esme.account_name = octstr_duplicate(esme->system_id);
	msg->smpp_esme.account_msg_id = octstr_duplicate(resp->u.submit_sm_resp.message_id);
	msg->smpp_esme.req_time = get_current_datetime();
	msg->smpp_esme.source_addr = octstr_duplicate(pdu->u.submit_sm.source_addr);
	msg->smpp_esme.dest_addr = octstr_duplicate(pdu->u.submit_sm.destination_addr);
	msg->smpp_esme.msg_content = octstr_duplicate(pdu->u.submit_sm.short_message);
	msg->smpp_esme.submit_status = resp->u.submit_sm_resp.command_status;
	msg->smpp_esme.esm_class = pdu->u.submit_sm.esm_class;
	msg->smpp_esme.data_coding = pdu->u.submit_sm.data_coding;
	msg->smpp_esme.esm_class = pdu->u.submit_sm.esm_class;
	msg->smpp_esme.more_messages_to_send = pdu->u.submit_sm.more_messages_to_send;
	msg->smpp_esme.IP = octstr_duplicate(((ESME_TX*)session_str)->client_ip);
	if(dndcheck_flag==0)
		msg->smpp_esme.dnd_flag = -1;
	else
		msg->smpp_esme.dnd_flag = 0;
	if(pdu->u.submit_sm.user_response_code != -1)
		msg->smpp_esme.retry_value = pdu->u.submit_sm.user_response_code;
	else
		msg->smpp_esme.retry_value = 0;

	if(msg->smpp_esme.data_coding != 0){
		octstr_binary_to_hex(msg->smpp_esme.msg_content, 1);
	}
	//send_msg_process_client(dbbox_client,msg);
	send_msg_dbbox_server(msg,0);
	if(resp->u.submit_sm_resp.command_status == 0)
	{

		alog("SMS Sent [ESME:%sMode:%dSession:%d][IP:%s][ESME_MSGID:%s][FROM:%s][TO:%s]",
				octstr_get_cstr(esme->system_id),mode,session_id,
				octstr_get_cstr(((ESME_TX*)session_str)->client_ip),
				octstr_get_cstr(resp->u.submit_sm_resp.message_id),
				octstr_get_cstr(pdu->u.submit_sm.source_addr),
				octstr_get_cstr(pdu->u.submit_sm.destination_addr)
		    );	
	}	
	else
	{
		mis_db_insert(esme->system_id,resp->u.submit_sm_resp.message_id,pdu,resp->u.submit_sm_resp.command_status,((ESME_TX*)session_str)->client_ip);
		alog("SMS Rejected [ESME:%sMode:%dSession:%d][IP:%s][ESME_MSGID:%s][FROM:%s][TO:%s]",
				octstr_get_cstr(esme->system_id),mode,session_id,
				octstr_get_cstr(((ESME_TX*)session_str)->client_ip),
				octstr_get_cstr(resp->u.submit_sm_resp.message_id),
				octstr_get_cstr(pdu->u.submit_sm.source_addr),
				octstr_get_cstr(pdu->u.submit_sm.destination_addr)
		    );	

	}	
	if(mode == 1)
		counter_increase(((ESME_TX*)session_str)->msg_received);
	return resp;
}


static SMPP_PDU *handle_deliver_sm_resp(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	return NULL;
}
static SMPP_PDU *handle_unbind_resp(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	if(mode == 1)
		((ESME_TX*)session_str)->quit = 1;
	else if(mode == 2)
		((ESME_RX*)session_str)->quit = 1;
	return NULL;
}
static SMPP_PDU *handle_enquire_link(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	return smpp_pdu_create(enquire_link_resp, 
			pdu->u.enquire_link.sequence_number);
}


static SMPP_PDU *handle_enquire_link_resp(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	return NULL;
}
/*
   in case generic nack is received from esme we display the esme id and command status for the same
   When sent by client server will just display that last command was rejected by the client.
   */
static SMPP_PDU *handle_generic_nack(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{

	long cmd_stat;
	cmd_stat  = pdu->u.generic_nack.command_status;
	error(0, "ESME[%s]: ESME rejected last command code 0x%08lx (%s).",
			octstr_get_cstr(esme->system_id),
			cmd_stat,
			smpp_error_to_string(cmd_stat));
	return NULL;
}
SMPP_PDU *handle_unbind(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	SMPP_PDU *resp;

	info(0,"Received unbind from :%s Mode :%d, Session :%d",octstr_get_cstr(esme->system_id),mode,session_id);
	resp = smpp_pdu_create(unbind_resp, pdu->u.unbind.sequence_number);
	if(mode == 1)
		((ESME_TX*)session_str)->status = ESME_UNCONNECTED;
	else if(mode == 2)
		((ESME_RX*)session_str)->status = ESME_UNCONNECTED;
	return resp;
}
SMPP_PDU *handle_cancel_sm(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	SMPP_PDU *resp;

	resp = smpp_pdu_create(cancel_sm_resp, pdu->u.cancel_sm.sequence_number);
	resp->u.cancel_sm_resp.command_status = SMPP_ESME_RCANCELFAIL; 
	return resp;
}
SMPP_PDU *handle_replace_sm(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	SMPP_PDU *resp;

	resp = smpp_pdu_create(replace_sm_resp, pdu->u.replace_sm.sequence_number);
	resp->u.replace_sm_resp.command_status = SMPP_ESME_RREPLACEFAIL; 
	return resp;
}
SMPP_PDU *handle_query_sm(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int session_id)
{
	SMPP_PDU *resp;

	resp = smpp_pdu_create(query_sm_resp, pdu->u.query_sm.sequence_number);
	resp->u.query_sm_resp.command_status = SMPP_ESME_RQUERYFAIL; 
	return resp;
}

static struct 
{
	unsigned long type;
	SMPP_PDU *(*handler)(ESME *, SMPP_PDU *,int mode,void *session_str,int session_id);
} 
handlers[] = 
{
#define HANDLER(name) { name, handle_ ## name },
	HANDLER(generic_nack)
		HANDLER(enquire_link)
		HANDLER(enquire_link_resp)
		HANDLER(submit_sm)
		HANDLER(deliver_sm_resp)
		HANDLER(unbind)
		HANDLER(unbind_resp)
		HANDLER(cancel_sm)
		HANDLER(replace_sm)
		HANDLER(query_sm)	
#undef HANDLER
};

//[2001108] [Added for tempConn]
static struct
{
	unsigned long type;
	MSG_BIND_INFO *(*handler_conn)(TEMPCONN *, SMPP_PDU *);
}
handlers_conn[] =
{
#define HANDLER_CONN(name) { name, handle_ ## name },
	HANDLER_CONN(bind_transmitter)
		HANDLER_CONN(bind_receiver)
		HANDLER_CONN(bind_transceiver)
#undef HANDLER_CONN
};

static int num_handlers = sizeof(handlers) / sizeof(handlers[0]);

//[2001108] [Added for tempConn]
static int num_handlers_conn = sizeof(handlers_conn) / sizeof(handlers_conn[0]);

static void handle_pdu(ESME *esme, SMPP_PDU *pdu,int mode,void *session_str,int thread_session_id)
{
	struct timeb tmb;
	ftime(&tmb);
	info(0,"tmb.time     =%s %ld (seconds)\n",pdu->type_name, tmb.time);
	info(0,"tmb.millitm  =%s %d (mlliseconds)\n",pdu->type_name, tmb.millitm);
	SMPP_PDU *resp;
	Octstr *os;
	int i;
	SMPP_PDU *generic_pdu = NULL;
	int session_id;
	/*
	   if(	(pdu->type == bind_transmitter) 		|| 
	   (pdu->type == bind_receiver) 			||
	   (pdu->type == bind_transceiver) 		
	   )
	   {

	   init_log_file(pdu->u.bind_transmitter.system_id,translations);
	   log_thread_to(esme->log_idx);
	   log_smsc_info();
	   debug("test.smpp", 0, "-------------------BIND RECEIVED FROM-------------:%s",\
	   octstr_get_cstr(pdu->u.bind_transmitter.system_id));
	   }

	   debug("test.smpp", 0, "Handling SMPP PDU of type %s received from : %s mode :%d",
	   pdu->type_name,octstr_get_cstr(esme->system_id),mode);
	   */
	debug("test.smpp", 0, "ESME[ID:%s,Mode:%d,Session:%d]:GOT PDU :%s",
			esme->system_id != NULL ? octstr_get_cstr(esme->system_id):"",
			mode,
			thread_session_id,
			pdu->type_name);
	smpp_pdu_dump(pdu);
	for (i = 0; i < num_handlers; ++i) 
	{
		if (handlers[i].type == pdu->type) 
		{
			resp = handlers[i].handler(esme, pdu,mode,(void*)session_str,thread_session_id);
			if((resp != NULL)&&(handlers[i].type != generic_nack)) 
			{
				/*increment the sequence number of as the pdu is received
				  counter_set(esme->seq_number_counter,pdu->u.bind_transmitter.sequence_number);
				//printf("\nPresent Counter value is :%d\n",counter_value(esme->seq_number_counter));
				*/
				debug("test.smpp", 0, "ESME[ID:%s,Mode:%d,Session Id :%d] SENDING PDU :%s",octstr_get_cstr(esme->system_id),mode,thread_session_id,resp->type_name);
				smpp_pdu_dump(resp);
				os = smpp_pdu_pack(resp);
				if(mode == 1)
					conn_write(((ESME_TX*)session_str)->conn, os);
				else if(mode == 2 )
					conn_write(((ESME_RX*)session_str)->conn, os);
				octstr_destroy(os);
				smpp_pdu_destroy(resp);
			}

			return;
		}
	}//for

	error(0, "Unhandled SMPP PDU.");
	smpp_pdu_dump(pdu);
	/*in case we recive a pdu which cannot be handled by the server we send a generic nack pru to the
	  originator..
	  Set to the sequence number of the last pdu received*/
	generic_pdu = smpp_pdu_create(generic_nack, pdu->u.generic_nack.sequence_number);
	generic_pdu->u.generic_nack.command_status = SMPP_ESME_RINVCMDID;
	debug("test.smpp", 0, "ESME[ID:%s,Mode:%d,SessionID:%d] SENDING PDU :%s",octstr_get_cstr(esme->system_id),mode,thread_session_id,generic_pdu->type_name);
	smpp_pdu_dump(generic_pdu);
	os = smpp_pdu_pack(generic_pdu);
	if(mode == 1)
		conn_write(((ESME_TX*)session_str)->conn, os);
	else if(mode == 2 )
		conn_write(((ESME_RX*)session_str)->conn, os);
	octstr_destroy(os);
	smpp_pdu_destroy(generic_pdu);	
}

//[201108] [For tempConn]
static ESME* handle_pdu_bind(TEMPCONN *temp_conn, SMPP_PDU *pdu)
{
	MSG_BIND_INFO *msgresp_ptr;	
	SMPP_PDU *resp;
	Octstr *os;
	int i;
	SMPP_PDU *generic_pdu = NULL;
	ESME *return_esme = NULL;

	if(	
			(pdu->type == bind_transmitter) 		|| 
			(pdu->type == bind_receiver) 			||
			(pdu->type == bind_transceiver) 		
	  )
	{

		log_thread_to(init_log_file(pdu->u.bind_transmitter.system_id,translations,temp_conn->mode));
		log_smsc_info();
		debug("test.smpp", 0, "-------------------BIND RECEIVED FROM-------------:%s",\
				octstr_get_cstr(pdu->u.bind_transmitter.system_id));
	}

	//debug("test.smpp", 0, "Handling SMPP PDU of type %s received from : %s",pdu->type_name,octstr_get_cstr(temp_conn->client_ip));
	debug("test.smpp", 0, "ESME[%s]:GOT PDU :%s",octstr_get_cstr(temp_conn->client_ip),(pdu)->type_name);
	smpp_pdu_dump(pdu);
	for (i = 0; i < num_handlers_conn; ++i) 
	{
		if (handlers_conn[i].type == pdu->type) 
		{
			msgresp_ptr = handlers_conn[i].handler_conn(temp_conn, pdu);
			resp = msgresp_ptr->resp;
			if((resp != NULL)) 
			{
				debug("test.smpp", 0, "ESME[%s] SENDING PDU :%s",octstr_get_cstr(temp_conn->client_ip),resp->type_name);
				smpp_pdu_dump(resp);
				os = smpp_pdu_pack(resp);
				conn_write(temp_conn->conn, os);
				octstr_destroy(os);
				smpp_pdu_destroy(resp);
			}
			return_esme = msgresp_ptr->esme;
			/*
			   if(return_esme != NULL)
			//printf("\n\nHandle PDU BIND :%s\n\n",octstr_get_cstr(return_esme->system_id));
			*/
			gw_free(msgresp_ptr);
			return return_esme;
		}
	}//for

	error(0, "Unhandled SMPP PDU.");
	smpp_pdu_dump(pdu);
	/*in case we recive a pdu which cannot be handled by the server we send a generic nack pru to the
	  originator..
	  Set to the sequence number of the last pdu received*/
	generic_pdu = smpp_pdu_create(generic_nack, pdu->u.generic_nack.sequence_number);
	generic_pdu->u.generic_nack.command_status = SMPP_ESME_RINVCMDID;
	smpp_pdu_dump(generic_pdu);
	debug("test.smpp", 0, "ESME[%s] SENDING PDU :%s",octstr_get_cstr(temp_conn->client_ip),generic_pdu->type_name);
	os = smpp_pdu_pack(generic_pdu);
	conn_write(temp_conn->conn, os);
	octstr_destroy(os);
	smpp_pdu_destroy(generic_pdu);	
	return NULL;
}


static void send_enquire_link(int mode,Octstr *conn_name,Connection *conn, long *last_sent,long enquire_link_interval,Counter **seq_counter,int session_id)
{
	SMPP_PDU *pdu;
	Octstr *os;

	if (date_universal_now() - *last_sent < enquire_link_interval)
		return;
	*last_sent = date_universal_now();

	pdu = smpp_pdu_create(enquire_link, counter_increase(*seq_counter));
	debug("test.smpp", 0, "ESME[ID:%s,Mode:%d,Session ID:%d] SENDING PDU :%s",octstr_get_cstr(conn_name),mode,session_id,pdu->type_name);
	smpp_pdu_dump(pdu);
	os = smpp_pdu_pack(pdu);
	if (os)
		conn_write(conn, os); /* Write errors checked by caller. */
	octstr_destroy(os);
	smpp_pdu_destroy(pdu);
}

static void send_unbind(int mode,Octstr *conn_name,Connection *conn,Counter **seq_counter,int session_id)
{
	SMPP_PDU *pdu;
	Octstr *os;
	pdu = smpp_pdu_create(unbind, counter_increase(*seq_counter));
	debug("test.smpp", 0, "ESME[ID:%s,Mode:%d,Session ID:%d] SENDING PDU :%s",octstr_get_cstr(conn_name),mode,session_id,pdu->type_name);
	smpp_pdu_dump(pdu);
	os = smpp_pdu_pack(pdu);
	if (os)
		conn_write(conn, os); /* Write errors checked by caller. */
	octstr_destroy(os);
	smpp_pdu_destroy(pdu);
}



/* 
 * Try to read an SMPP PDU from a Connection. Return -1 for error (caller 
 * should close the connection), 0 for no PDU to ready yet, or 1 for PDU 
 * read and unpacked. Return a pointer to the PDU in `*pdu'. Use `*len' 
 * to store the length of the PDU to read (it may be possible to read the 
 * length, but not the rest of the PDU - we need to remember the lenght 
 * for the next call). `*len' should be zero at the first call. 
 */

/*conn_name is required cos it is possible that we are reading when when we dont have any bind received.
  That time read pdu should print IP*/
static int read_pdu(Octstr *conn_name, Connection *conn, long *len, SMPP_PDU **pdu) 
{ 
	Octstr *os; 

	if (*len == 0) 
	{ 
		*len = smpp_pdu_read_len(conn); 
		if (*len == -1) 
		{ 
			error(0, "SMPP[%s]: Server sent garbage, ignored.",octstr_get_cstr(conn_name)); 
			return -1; 
		} 
		else if (*len == 0) 
		{ 
			if (conn_eof(conn) || conn_error(conn)) 
				return -1; 
			return 0; 
		} 
	} 

	os = smpp_pdu_read_data(conn, *len); 
	if (os == NULL) 
	{ 
		if (conn_eof(conn) || conn_error(conn)) 
			return -1; 
		return 0; 
	} 
	*len = 0; 

	*pdu = smpp_pdu_unpack(os); 
	if (*pdu == NULL) 
	{ 
		error(0, "SMPP[%s]: PDU unpacking failed.",octstr_get_cstr(conn_name)); 
		debug("bb.sms.smpp", 0, "SMPP[%s]: Failed PDU follows.",octstr_get_cstr(conn_name)); 
		octstr_dump(os, 0); 
		octstr_destroy(os);
		return -1;
	}

	octstr_destroy(os);

	return 1;
}



static void receive_smpp_thread(void *arg)
{
	ESME *esme;
	TEMPCONN *temp_conn;	
	Octstr *os;
	long len;
	long sender_id;
	long last_enquire_sent;
	long last_response;
	SMPP_PDU *pdu;
	int ret = 0;
	double timeout;    

	/**/
	Connection *thread_conn;
	int thread_type = 0;/*does not depend upon mode 1 for tx,2 for rx*/
	int *status;
	Counter *thread_counter = NULL;
	int *thread_quit;
	void *session_str = NULL;
	int thread_session_id;	



	len = 0;
	temp_conn = arg;
	/*After connection is established bind should be received in max 5sec else connection will be broken*/
	ret = conn_wait(temp_conn->conn, 5.00); 
	if(ret == 1)
	{
		error(0, "Time Out expired no BIND is received");
		goto error2;
	}
	if(ret == -1)
	{
		error(0, "Connection Broken");
		goto error2;
	}

	if((ret = read_pdu(temp_conn->client_ip,temp_conn->conn,&len,&pdu)) == 1)
	{
		esme = handle_pdu_bind(temp_conn, pdu);
		smpp_pdu_destroy(pdu);
		if(temp_conn->bind_successful == 0) 
		{	
			error(0, "Breaking cos of unsuccessful bind");
			goto error2;
		}
		////printf("\n\nRECEIVE SMPP THREAD :%s\n\n",octstr_get_cstr(esme->system_id));			  	
	}//if
	//27/1/09 - JR.
	if((ret == -1 && len == 0) ||(ret == -1 && len == -1))
	{
		error(0, "Breaking cos error in reading the PDU");
		goto error2;
	}
	if(conn_eof(temp_conn->conn) || conn_error(temp_conn->conn))
	{
		error(0, "Breaking cos connection is broken");
		goto error2;
	}
	if(esme == NULL)
	{
		error(0, "ESME structure not initialised");
		goto error2;
	}

	session_str = get_session_str(esme,temp_conn->mode,temp_conn->session_id);

	if(temp_conn->mode == 1 || temp_conn->mode == 3) /**/
	{

		thread_conn = ((ESME_TX*)session_str)->conn;
		thread_type = 1;
		status = &(((ESME_TX*)session_str)->status);
		thread_quit = &(((ESME_TX*)session_str)->quit);
		thread_counter = ((ESME_TX*)session_str)->seq_number_counter;
		thread_session_id = temp_conn->session_id;
	}
	else if((temp_conn->mode == 2) || (temp_conn->mode == 4))/**/
	{
		thread_conn = ((ESME_RX*)session_str)->conn;
		thread_type = 2;
		status = &(((ESME_RX*)session_str)->status);
		thread_quit = &(((ESME_RX*)session_str)->quit);
		thread_counter = ((ESME_RX*)session_str)->seq_number_counter;
		thread_session_id = temp_conn->session_id;
	}
	tempconn_destroy(temp_conn);
	temp_conn = NULL;
	len = 0;
	last_enquire_sent = date_universal_now();
	info(0,"ESME[%s]: Connection Details[ONLINE]-Mode:%d,Session:%d",
			octstr_get_cstr(esme->system_id),
			thread_type,thread_session_id);	
	while (!quitting)
	{

		for(;thread_conn != NULL;)//corrected on 27/1/09-J.R
		{

			timeout = 	last_enquire_sent 
				+ esme->enquire_link_interval
				- date_universal_now();


			if(conn_wait(thread_conn,timeout) == -1)
			{
				error(0,"ESME[%s]: Connection Details[OFFLINE]-Socket Error Mode:%d,Session id:%d",octstr_get_cstr(esme->system_id),thread_type,thread_session_id);
				goto error;
			}

			////printf("\n\nAFTER CONN TIMEOUT\n\n");

			if((*status == ESME_DISCONNECT)||(*status == ESME_SEND_UNBIND))
			{
				/* 	unbind
				 * Read so long as unbind_resp received or timeout passed. Otherwise we have
				 * double delivered messages.
				 */
				send_unbind(thread_type,esme->system_id,thread_conn,&thread_counter,thread_session_id);
				info(0,"ESME[%s]: Connection Details[OFFLINE]-Sending unbind Mode:%d,Session:%d",octstr_get_cstr(esme->system_id),thread_type,thread_session_id);
				last_response = time(NULL);
				while(	conn_wait(thread_conn, 1.00) != -1 										&&
						difftime(time(NULL), last_response) < SMPP_DEFAULT_SHUTDOWN_TIMEOUT		&&
						*thread_quit != 1
				     )
				{
					if(read_pdu(esme->system_id,thread_conn,&len,&pdu) == 1)
					{
						handle_pdu(esme,pdu,thread_type,session_str,thread_session_id);
						smpp_pdu_destroy(pdu);
					}
				}

				goto error;
			}

			else if((*status == ESME_BINDED)||(*status == ESME_SMSC_UNCONNECTED))
				send_enquire_link(thread_type,esme->system_id,thread_conn,&last_enquire_sent,esme->enquire_link_interval,&thread_counter,thread_session_id);

			while((ret = read_pdu(esme->system_id,thread_conn,&len,&pdu)) == 1)
			{
				handle_pdu(esme, pdu,thread_type,session_str,thread_session_id);
				smpp_pdu_destroy(pdu);

				/*this makes sure that we write even when we read a lot*/

				write_esme_conn(esme,thread_type,session_str,thread_session_id);
				////printf("\n\nAFTER CONN TIMEOUT---------3\n\n");
				/*This makes sure that enquire link is sent when there is lots of data read/written*/

				if((*status == ESME_BINDED)||(*status == ESME_SMSC_UNCONNECTED))
					send_enquire_link(thread_type,esme->system_id,thread_conn,&last_enquire_sent,esme->enquire_link_interval,&thread_counter,thread_session_id);

			}//while
			if(*status == ESME_UNCONNECTED)
			{
				info(0,"ESME[%s]: Connection Details[OFFLINE]-Unbind received Mode:%d,Session :%d",octstr_get_cstr(esme->system_id),thread_type,thread_session_id);
				goto error;
			}			
			if((ret == -1) && (len == -1))
			{
				error(0, "ESME[%s]: Connection Details[OFFLINE]-Client sent garbage, closing connection.",octstr_get_cstr(esme->system_id));
				goto error;
			}
			if((ret == -1)&&(len == 0))
			{
				error(0,"ESME[%s]: Connection Details[OFFLINE]-Error in reading/writing",octstr_get_cstr(esme->system_id));	
				goto error;		    	
			}
			if (conn_eof(thread_conn) || conn_error(thread_conn))
			{
				error(0,"ESME[%s]: Connection Details[OFFLINE]-Socket received EOF",octstr_get_cstr(esme->system_id));
				goto error;
			}
			write_esme_conn(esme,thread_type,session_str,thread_session_id);			
		}//for	
	}//while
error: 
	info(0, "in GOTO %s terminates account :%s mode :%d.",
			__func__,octstr_get_cstr(esme->system_id),thread_type);
	esme_destroy(esme,thread_type,thread_session_id);
error2:
	info(0, "in GOTO1 %s terminates. :%d", __func__,thread_type);
	tempconn_destroy(temp_conn);

}

static void accept_trans_thread(void *arg)
{
	int fd;
	int new_fd;
	int port;
	socklen_t addrlen;
	struct sockaddr_in addr;
	long smsbox_thread_id;

	char client_ip[30];

	port = *(int *) arg;
	fd = make_server_socket(port, NULL);
	if (fd == -1)
		panic(0, "Couldn't create SMPP listen port:TRANSMITTER.:%d",port);

	smsbox_thread_id = -1;

	for(;;) 
	{

		if (gwthread_pollfd(fd, POLLIN, -1.0) != POLLIN)
			break;
		addrlen = sizeof(addr);
		new_fd = accept(fd, (struct sockaddr *)&addr, (socklen_t *)&addrlen);
		inet_ntop(addr.sin_family,&addr.sin_addr.s_addr,client_ip,sizeof(addr));
		info(0, "Func[%s] Client : %s connected on trans port : %d",__func__,client_ip,new_fd);
		if (start_time == (time_t) -1)
			time(&start_time);
		gwthread_create(receive_smpp_thread,(tempconn_create((conn_wrap_fd(new_fd, 0)),
						client_ip,
						ntohs(addr.sin_port),
						port,1)));


		/*
		   if (smsbox_thread_id == -1)
		   smsbox_thread_id = gwthread_create(smsbox_thread, NULL);
		   */
	}	

	info(0, "%s terminates.", __func__);
}//accept trans thread


static void accept_recv_thread(void *arg)
{
	int fd;
	int new_fd;
	int port;
	socklen_t addrlen;
	struct sockaddr_in addr;
	/*
	   long smsbox_thread_id;
	   */
	char client_ip[30];



	port = *(int *) arg;
	fd = make_server_socket(port, NULL);
	if (fd == -1)
		panic(0, "Couldn't create SMPP listen port:RECEIVER");


	for(;;) 
	{

		if (gwthread_pollfd(fd, POLLIN, -1.0) != POLLIN)
			break;
		addrlen = sizeof(addr);
		new_fd = accept(fd, (struct sockaddr *)&addr, (socklen_t *)&addrlen);
		inet_ntop(addr.sin_family,&addr.sin_addr.s_addr,client_ip,sizeof(addr));
		info(0, "Func[%s] Client : %s connected on recv port",__func__,client_ip);
		if (start_time == (time_t) -1)
			time(&start_time);

		gwthread_create(receive_smpp_thread,(tempconn_create((conn_wrap_fd(new_fd, 0)),client_ip,ntohs(addr.sin_port),port,2)));

		/*
		   if (smsbox_thread_id == -1)
		   smsbox_thread_id = gwthread_create(smsbox_thread, NULL);
		   */
	}	

	info(0, "%s terminates.", __func__);

}//accept recv thread


static void accept_transrecv_thread(void *arg)
{
	int fd;
	int new_fd;
	int port;
	socklen_t addrlen;
	struct sockaddr_in addr;
	/*
	   long smsbox_thread_id;
	   */



	char client_ip[30];
	port = *(int *) arg;
	fd = make_server_socket(port, NULL);
	if (fd == -1)
		panic(0, "Couldn't create SMPP listen port.:TRANRECIVER");


	for(;;) 
	{

		if (gwthread_pollfd(fd, POLLIN, -1.0) != POLLIN)
		{
			printf("breaking from the loop.........\n");
			break;
		}
		addrlen = sizeof(addr);
		new_fd = accept(fd, (struct sockaddr *)&addr, (socklen_t *)&addrlen);
		inet_ntop(addr.sin_family,&addr.sin_addr.s_addr,client_ip,sizeof(addr));
		info(0, "Func[%s] Client : %s connected on transrecv port",__func__,client_ip);
		if (start_time == (time_t) -1)
			time(&start_time);
		gwthread_create(receive_smpp_thread,(tempconn_create((conn_wrap_fd(new_fd, 0)),
						client_ip,
						ntohs(addr.sin_port),
						port,1)));

		/*
		   if (smsbox_thread_id == -1)
		   smsbox_thread_id = gwthread_create(smsbox_thread, NULL);
		   */
	}

	info( 0, "%s terminates.", __func__);

}//accept transrecv thread

void wait_msg_recv(void *arg)
{

	Octstr *os = NULL;
	Octstr *new;

	//Octstr *try = NULL;	

	struct reverse_queue_data *rqd_ptr;
	Connection *esme_conn;
	int ret = 0;
	Octstr *account_name = NULL;



	debug("wait_msg_recv.c", 0, "wait_msg_recv Started");
	unsigned int number_of_smsc = 0;

	struct db_extract_values db_extract;

	ESME *esme = NULL;
	void *ptr = NULL;
	int msg_type = 0;
	SMPP_PDU *pdu;
	struct msg_deliver *msg_deliver_ptr;

	Conn_Msg *msg;
	Octstr *key;
	/*
	   int i;
	   for(i = 0; i < number_of_smsc; i++)
	   {
	//printf("\nName : %s,status :%d\n",smsc_info_ptr[i].smsc_id,smsc_info_ptr[i].conn_status);
	}
	*/

	for(;;)
	{
		/*
		   rqd_ptr = gw_malloc(sizeof(struct reverse_queue_data));
		   gw_assert(rqd_ptr != NULL);

		   os = recv_msg_reverse_q(FORWARD_MSGQ_TYPE,0,rqd_ptr);
		////printf("\nAFTER MESSAGE RECV\n");
		if(os == NULL)
		{
		gw_free(rqd_ptr);
		break;
		}	
		key = octstr_format("%s%s",rqd_ptr->smsc_msg_id,rqd_ptr->dest_addr);	
		dict_put(pending_deliver_sm,key,os);
		octstr_destroy(key);

		msg = conn_msg_create(values_get);
		msg->values_get.smsc_msg_id = octstr_create(rqd_ptr->smsc_msg_id);
		msg->values_get.dest_addr = octstr_create(rqd_ptr->dest_addr);
		send_msg_process_client(dbbox_client,msg);
		debug("wait_msg_recv.c", 0, "Rerverse Q SMSC_ID:%s:SMSCMSGID:%s:DEST:%s",\
		rqd_ptr->smsc_id,rqd_ptr->smsc_msg_id,rqd_ptr->dest_addr);			

		gw_free(rqd_ptr);
		/*
		send message to database to extract acc info for smsc_id/smscmsg_id
		*/

		/*for testing*/
		/*
		   strcpy(db_extract.smsc_id,rqd_ptr->smsc_id);
		   strcpy(db_extract.smsc_msg_id,rqd_ptr->smsc_msg_id);
		   strcpy(db_extract.dest_addr,rqd_ptr->dest_addr);
		   send_msg_database_q(DATABASE_MSGQ_TYPE,GET_VALUES,0,&db_extract);
		   */
		/*for testing*/

		/*
		   wait to recv a message from the dbbox containing account info
		   */
		/*	
			debug("wait msg rcv",0,"WAITING FOR RECV MESSAGE QUEUE");
			recv_msg_database_q(MAPPING_MSGQ_TYPE,&msg_type,0,&ptr);
			if(ptr == NULL)
			{
			if(program_status == PROGRAM_RUNNING)
			{
			panic(0, "INVALID PARAMETERS ARE FOUND WHILE EXTRACTING ACCOUNT INFO");				
			}
			else
			break;
			}

			debug("wait msg recv",0,"After MES RECV ID :%d success:%d\n",msg_type,((struct db_extracted_values *)ptr)->result);
			if(	(msg_type == EXTRACTED_VALUES)					&&
			(((struct db_extracted_values *)ptr)->result)
			)
			{
			debug("wait msg recv.c", 0, "Account information Acc : %s msg_id :%s",((struct db_extracted_values *)ptr)->account_name,
			((struct db_extracted_values *)ptr)->account_msg_id);

			}
			else
			{
			debug("wait msg recv.c", 0, "No account found for the message");
			octstr_destroy(os);
			gw_free(rqd_ptr);
			gw_free(ptr);
			continue;
			}	
			account_name = octstr_create(((struct db_extracted_values *)ptr)->account_name);	
			esme = extract_esme(account_name);
			if(esme == NULL)
			{
			ret = extract_log_idx(account_name);
			if(ret != -1)
			write_to_logfile(ret,GW_DEBUG,0,"RX ESME DOES NOT EXISTS FOR ACCOUNT NAME: %s AND ID :%s", octstr_get_cstr(account_name),((struct db_extracted_values *)ptr)->account_msg_id);
			else
			error(0, "RX ESME DOES NOT EXISTS FOR ACCOUNT NAME: %s AND ID :%s", octstr_get_cstr(account_name),((struct db_extracted_values *)ptr)->account_msg_id);
			octstr_destroy(account_name);
			octstr_destroy(os);
			gw_free(rqd_ptr);
			gw_free(ptr);
			continue;
			}
			msg_deliver_ptr = gw_malloc(sizeof(struct msg_deliver));
			msg_deliver_ptr->smsc_id = octstr_create(rqd_ptr->smsc_id);
			msg_deliver_ptr->smsc_msg_id = octstr_create(rqd_ptr->smsc_msg_id);
			msg_deliver_ptr->account_msg_id = octstr_create(((struct db_extracted_values *)ptr)->account_msg_id);
			msg_deliver_ptr->os = octstr_duplicate(os);

		//[sanchal][181108][Added for txrx mode]
		if(esme->esmerx != NULL)
		{
		gwlist_produce(esme->esmerx->data_to_write,msg_deliver_ptr);
		gwthread_wakeup(esme->rx_thread_id);
		}
		else if ( esme->mode == 3 )
		{
		gwlist_produce(esme->esmetx->data_to_write,msg_deliver_ptr);
		gwthread_wakeup(esme->tx_thread_id);
		}
		else 
		{
		error(0, "No ESME For writing deliver_sm");
		}

		octstr_destroy(os);
		gw_free(rqd_ptr);
		gw_free(ptr);
		octstr_destroy(account_name);		
		*/	
	}//infinte loop
	info(0, "%s terminates.", __func__);

}//wait msg recv thread

void system_thread(void *arg)
{
	int res;
	int no_of_smsc;
	int exit_thread = 0;
	int init_smsc = 0;
	struct smsc_info *smsc_info_ptr = NULL;


	//debug("system_thread.c", 0, "\nAFTER SYSTEM MESSAGE RECV - SYSTEM THREAD--------\n");

	for(;;)
	{
		struct first_information *first_info_ptr;
		first_info_ptr = gw_malloc(sizeof(struct first_information));
		res =  recv_msg_system_q(SYSTEM_Q_FIRST_INFO,0,0,first_info_ptr);
		////printf("\nAFTER SYSTEM MESSAGE RECV - SERVER\n");
		debug("system thread", 0, "system_thread Value 1 : %d",first_info_ptr->msg_id);
		debug("system thread", 0, "system_thread Value 2 : %d",first_info_ptr->next_msg_type);
		debug("system thread", 0, "system_thread Value 3 : %d",first_info_ptr->next_data_len);			
		switch(first_info_ptr->next_msg_type)
		{
			case TERMINATE_SYSTEM_THREAD:
				{
					exit_thread = 1;
					break;
				}
			case NO_OF_SMSC_CONNECTED:
				{
					res =  recv_msg_system_q(NO_OF_SMSC_CONNECTED,0,0,&no_of_smsc);
					info(0, "No of SMSC's connected : %d",no_of_smsc);
					break;
				}

			case SMSC_INFORMATION:
				{
					int i;
					smsc_info_ptr = gw_malloc(first_info_ptr->next_data_len);
					no_of_smsc = (first_info_ptr->next_data_len)/(sizeof(struct smsc_info));
					res =  recv_msg_system_q(SMSC_INFORMATION,no_of_smsc,0,smsc_info_ptr);
					for(i = 0; i < no_of_smsc; i++)
					{
						//printf("\nName : %s,Status :%d, Type :%s\n",smsc_info_ptr[i].smsc_id,smsc_info_ptr[i].conn_status,smsc_info_ptr[i].smsc_type);

					}	
					if(init_smsc == 0)
					{
						//prepare_smsc_list(no_of_smsc,smsc_info_ptr);
						init_smsc = 1;
					}
					else
					{
						//update_smsc_list(no_of_smsc,smsc_info_ptr);
						//update_emse_conn(translations);
					}

					//display_smsc_info();
					gw_free(smsc_info_ptr);
					break;
				}//SMSC_INFORMATION

			case SHUTDOWN_SERVER_SYSTEM:
				{
					pid_t process_thread_id;
					info( 0, "SERVER SYSTEM SHOULD BE SHUTDOWN");
					program_status = PROGRAM_SHUTDOWN; 
					process_thread_id = getpid();
					kill(process_thread_id,SIGINT);

					break;
				}//SHUTDOWN_SERVER_SYSTEM

			case CHANGE_LOG_FILE:
				{
					debug("system_thread.c", 0, "CHANGE LOG FILE ID");
					res  = change_logfile_name(log_file_index);
					if( res == 0)
					{
						Octstr *log_name = NULL;
						log_name = log_file_name(log_file_index);
						//info(0, "Log file changed successfully:%s",octstr_get_cstr(log_name));
						octstr_destroy(log_name);
					}
					if(access_file_name != NULL)
					{
						Octstr *log_name = NULL;
						log_name = change_access_file_name(access_file_name);
						if(log_name != NULL)
						{
							octstr_destroy(access_file_name);
							access_file_name = octstr_duplicate(log_name);
							octstr_destroy(log_name);
							//info(0, "Access Log file changed successfully:%s",octstr_get_cstr(access_file_name));					
						}
					}
					change_esme_logfile(translations);
					break;
				}						
		}

		gw_free(first_info_ptr);
		if(exit_thread == 1)
			break;

	}
	debug("test.smpp", 0, "%s terminates.", __func__);
}

void save_dbbox_q_msgs()
{
	Conn_Msg *msg;
	int i;
	int len;
	Octstr *tmp;
	SMPP_PDU *pdu;
	if(forward_client != NULL) 
	{
		len = gwlist_len(forward_client->send_list);	
		error(0,"Messages on forward q when shutting down the system:%d",len);
		/*first put all message on forward q to dbbox q using mis db insert
		  then from dbbox q handle the message*/
		for(i = 0; i < len; i++)
		{
			msg = gwlist_extract_first(forward_client->send_list);
			if(msg == NULL)
				continue;
			if(conn_msg_type(msg) != submit)
			{
				conn_msg_destroy(msg);
				continue;
			}
			tmp = octstr_from_position(msg->submit.pdu,4);
			pdu = smpp_pdu_unpack(tmp);
			octstr_destroy(tmp);
			if((forward_client != NULL) &&(forward_client->status != PROCESS_CONNECTED))	
			{
				debug("test.smpp", 0, "----------BEFORE SENDING MESSAGE TO CLIENT---------1111");				
				mis_db_insert(	msg->submit.account_name,
						msg->submit.account_msg_id,
						pdu,
						0x00000408,msg->submit.account_name);
			}
			else
			{

				alog("SMS Rejected [FORWARDQ-SHUTDOWN][ESMEName:%s][ESMEMsgid:%s][ERR:%d:%s][FROM:%s][TO:%s][CONTENT:%s]",
						octstr_get_cstr(msg->submit.account_name),
						octstr_get_cstr(msg->submit.account_msg_id),
						0x00000408,smpp_error_to_string(0x00000408),
						pdu->u.submit_sm.source_addr == NULL? "<Empty>"		: octstr_get_cstr(pdu->u.submit_sm.source_addr),
						pdu->u.submit_sm.destination_addr == NULL?"<Empty>" : octstr_get_cstr(pdu->u.submit_sm.destination_addr),
						(pdu->u.submit_sm.esm_class & ESM_CLASS_SUBMIT_UDH_INDICATOR) == 0 ? (pdu->u.submit_sm.short_message == NULL ? "<Empty>":octstr_get_cstr(pdu->u.submit_sm.short_message)) :"<Binary Message>");
				conn_msg_destroy(msg);
			}
			smpp_pdu_destroy(pdu);
		}//for
		if(dbbox_client != NULL && dbbox_client->status != PROCESS_CONNECTED && gwlist_len(dbbox_client->send_list) > 0)
		{
			len = gwlist_len(dbbox_client->send_list);
			error(0,"Messages on dbbox q when shutting down the system:%d",len);
			for(i = 0 ; i < len; i++)
			{
				msg = gwlist_extract_first(dbbox_client->send_list);
				if(msg == NULL) 
					continue;
				/*Insert mis message will arrive only in situations when dbbox is shutdown forward q messages are inserted into dbbox q and dbbox connection is brken after that*/
				if((conn_msg_type(msg) == insert_mis) || (conn_msg_type(msg) == smpp_esme))
				{
					send_msg_dbbox_server(msg,1);
				}
				conn_msg_destroy(msg);
			}//for
		}
	}
	//sleep(3);
}

static void signal_handler(int signum)
{
	/* On some implementations (i.e. linuxthreads), signals are delivered
	 * to all threads.  We only want to handle each signal once for the
	 * entire box, and we let the gwthread wrapper take care of choosing
	 * one.
	 */



	if (!gwthread_shouldhandlesignal(signum))
		return;
	//printf("----------INSIDE SIGNAL RECEIVED------------------ : %d\n",signum);
	info(0,"--------------SIGNAL RECEIVED--------------- %d",signum);
	switch (signum) 
	{
		case SIGINT:
		case SIGTERM:
			{
				/*first stop ESME from sending messages then save all the messages on RAM to dbbox and then disconnect dbbox client*/
				program_status = PROGRAM_SHUTDOWN;/*first start rejecting the message*/
				esme_shutdown(1);/*first make sure all messages get written to dbbox q*/
				save_dbbox_q_msgs();/*send all q messages */
				smsc_shutdown();
				process_program_status = shutting_down;/*shutdown the all the client threads*/
				//send_msg_system_q(SYSTEM_Q_FIRST_INFO,TERMINATE_SYSTEM_THREAD,0,NULL);
				quit();
				break;
			}
		case SIGSEGV:
			{

				/*Printfs are required cos we are not sure whether debug will print information or not.*/
				int j, nptrs;
				void *buffer[50];
				char **strings;
				char funcname[100];
				nptrs = backtrace(buffer, 50);
				debug("bb", 0, "backtrace() returned %d addresses",nptrs);
				//printf("backtrace() returned %d addresses\n",nptrs);
				int *p = NULL;
				*p = 10;strings = backtrace_symbols(buffer, nptrs);
				if(strings == NULL)
				{
					perror("backtrace_symbols");
					exit(EXIT_FAILURE);
				}
				for(j = 0; j < nptrs; j++)
				{
					//printf("Function Value is :%s\n",strings[j]);
					debug("bb", 0, "Function Value is :%s",strings[j]);
				}
				gw_free(strings);
				gwthread_funcname(gwthread_self(),funcname);
				//printf("\nsignal_handler : %s\n",strsignal(signum));
				//printf("SIGSEGV Generated by Process:%ld Thread:%ld Name:%s\n",gwthread_self_pid(),gwthread_self(),funcname);

				/*
				   pthread_detach(pthread_self());
				   pthread_exit(pthread_self());
				   */


				program_status = PROGRAM_SHUTDOWN;/*first start rejecting the message*/
				esme_shutdown(1);/*first make sure all messages get written to dbbox q*/
				save_dbbox_q_msgs();/*send all q messages */
				smsc_shutdown();
				process_program_status = shutting_down;/*shutdown the all the client threads*/
				//send_msg_system_q(SYSTEM_Q_FIRST_INFO,TERMINATE_SYSTEM_THREAD,0,NULL);
				quit();
				panic(0, "SIGSEGV Generated by Process:%ld Thread:%ld Name:%s\n",gwthread_self_pid(),gwthread_self(),funcname);

				exit(0);
				break;
			}


		case SIGHUP:
			break;

			/* 
			 * It would be more proper to use SIGUSR1 for this, but on some
			 * platforms that's reserved by the pthread support. 
			 */

			break;
	}
}

static void setup_signal_handlers(void)
{
	struct sigaction act;
	act.sa_handler = signal_handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	sigaction(SIGINT, &act, NULL);
	sigaction(SIGTERM, &act, NULL);
	sigaction(SIGQUIT, &act, NULL);
	sigaction(SIGHUP, &act, NULL);
	sigaction(SIGPIPE, &act, NULL);
	//sigaction(SIGSEGV, &act, NULL);
}

static int check_args(int i, int argc, char **argv) 
{
	return 0;
} 

void manage_log(Cfg *cfg)
{
	CfgGroup *grp;

	Octstr *log_file = NULL;
	Octstr *new_log_file = NULL;
	grp = cfg_get_single_group(cfg, octstr_imm("core"));
	Octstr *retVallog;
	long lvl;
	int lf,m;
	Octstr *log;    //[sanchal][200309]
	long loglevel; //[sanchal][230309]
	char szTempVar[28]; //[sanchal][200309]

	logfile = NULL; 
	lf = m = 1;
	log = cfg_get(grp, octstr_imm("log-file"));
	if(log != NULL)
	{
		retVallog = get_latst_filename(log);
		if( retVallog == NULL )
		{
			Octstr *logfile = NULL;
			logfile = logfile_append_time(log);
			if(cfg_get_integer(&loglevel, grp, octstr_imm("log-level")) == -1)
				loglevel = 0;
			log_file_index = log_open(octstr_get_cstr(logfile), loglevel, GW_NON_EXCL);
			////printf(" \n\n --->> logfile : %s \n",octstr_get_cstr(logfile));
			info(0,"manage_log: New LogFile Name is :%s",octstr_get_cstr(logfile));
			octstr_destroy(logfile);
		}
		else
		{
			if(cfg_get_integer(&loglevel, grp, octstr_imm("log-level")) == -1)
				loglevel = 0;
			log_file_index = log_open(octstr_get_cstr(retVallog), loglevel, GW_NON_EXCL);
			////printf(" \n\n --->> retVallog : %s \n",octstr_get_cstr(retVallog));
			info(0,"manage_log: Latest LogFile Name is :%s",octstr_get_cstr(retVallog));
		}
		octstr_destroy(retVallog);
		octstr_destroy(log);
	}

	/*
	   if((log_file = cfg_get(grp, octstr_imm("access-log"))) != NULL) 
	   {
	   access_file_name = logfile_append_time(log_file);
	   alog_open(octstr_get_cstr(access_file_name), lf, m);
	   octstr_destroy(log_file);
	   }
	   */


	//[sanchal][230309]:
	Octstr *retVal;
	//[sanchal][170309][Open the access-log File]
	if ((log = cfg_get(grp, octstr_imm("access-log"))) != NULL)
	{
		info(0,"TEST 1 ----------:%s",octstr_get_cstr(log));
		//accesslog_conffile = octstr_duplicate(log);
		Octstr *tempaccesslog_name;
		retVal = get_latst_filename(log);
		info(0,"TEST RETURN VARIBALE----------:%s",octstr_get_cstr(retVal));
		if( retVal == 0 )
		{
			Octstr *logfile;
			logfile = logfile_append_time(log);
			alog_open(octstr_get_cstr(logfile), lf, m ? 0 : 1);
			tempaccesslog_name = octstr_duplicate(logfile);
			octstr_destroy(logfile);
		}
		else
		{
			tempaccesslog_name = octstr_duplicate(retVal);
			alog_open(octstr_get_cstr(retVal), lf, m ? 0 : 1);
		}

		alog ("alog_begins");

		access_file_name = tempaccesslog_name;
		octstr_destroy(log);
		octstr_destroy(retVal);
		//octstr_destroy(tempaccesslog_name);
	}
	info(0,"TEST 2----------:%s",octstr_get_cstr(access_file_name));

	//[sanchal] [170309][Reading the log file size from conf file]
	/* Get Access Log File size from configuration parameter */
	if (cfg_get_integer(&giLogSize, grp, octstr_imm("log-file-size")) != -1 ) {
		info(0, " Log Size is : %ld", giLogSize);
	}
	else
	{
		giLogSize = 1;
		info(0, " Default Log Size of 1MB is set");
		// [ Default Log Size is 1MB ]
	}

	//[sanchal][170309][ Reading the interval from configuration file]
	Octstr *manage_log_interval = NULL;
	if ((manage_log_interval = cfg_get(grp, octstr_imm("log-interval"))) != NULL) {
		strcpy( szTempVar,octstr_get_cstr(manage_log_interval));
		giManagelogInterval = atoi(szTempVar);
		info(0, "Manage Log Interval %d", giManagelogInterval);
	}
	else
	{
		giManagelogInterval = 60;
		//[ Default mange log interval as not given in conf file]
		info(0, "Default Manage Log Interval %d", giManagelogInterval);	
	}		
	octstr_destroy(manage_log_interval);
}

void manage_thread(Cfg *cfg)
{
	CfgGroup *grp;
	Octstr *log_file = NULL;
	Octstr *new_log_file = NULL;
	Octstr *compare_string;
	Octstr *date_string;
	Octstr *host = NULL;
	long port_num;
	long port_num1;
	long reconnect_delay;
	int ret;
	long ping_delay;
	long ping_ack_timeout;

	Octstr *log_name;

	pending_deliver_sm = dict_create(100,NULL);

	esme_init();
	smsc_init();


	grp = cfg_get_single_group(cfg, octstr_imm("core"));
	host = cfg_get(grp,octstr_imm("dbbox-host"));
	if(host == NULL)
		panic(0,"dbbox-host is not specified");
	if(cfg_get_integer(&port_num, grp, octstr_imm("dbbox-port")) == -1)
		panic(0,"dbbox-port is not specified");
	if(cfg_get_integer(&reconnect_delay, grp, octstr_imm("dbbox-reconnect-delay")) == -1)
	{
		warning(0,"dbbox-reconnect-delay is not specfied using 10 sec as default");
		reconnect_delay = 10;
	}
	if(cfg_get_integer(&ping_delay,grp,octstr_imm("dbbox-ping-delay")) == -1)
		ping_delay = 10;
	if(cfg_get_integer(&ping_ack_timeout,grp,octstr_imm("dbbox-pingack-timeout")) == -1)
		ping_ack_timeout = 5;


	dbbox_client = init_start_client(host,port_num,reconnect_delay,ping_delay,ping_ack_timeout);
	if(dbbox_client != NULL)
	{
		info(0,"DBBOX Client successfully initialised thread is :%d",dbbox_client->thread_id);
		Conn_Msg *msg;
		msg = conn_msg_create(admin);
		msg->admin.command = 1;
		msg->admin.conn_id = octstr_create("smpp-esme");
		dbbox_client->conn_id = octstr_create("dbbox-client");
		send_msg_process_client(dbbox_client,msg);
	}
	else
		panic(0,"Could not connect to dbbox");
	octstr_destroy(host);
	if(cfg_get_integer(&dndcheck_flag, grp, octstr_imm("dndcheck_flag")) == -1)
		panic(0,"dndcheck_flag is not specified");	
	host = cfg_get(grp,octstr_imm("smsc-host"));
	if(host == NULL)
		panic(0,"smsc-host is not specified");
	if(cfg_get_integer(&port_num, grp, octstr_imm("smsc-forward-port")) == -1)
		panic(0,"smsc-forward-port is not specified");
	if(cfg_get_integer(&port_num1, grp, octstr_imm("smsc-reverse-port")) == -1)
		panic(0,"smsc-reverse-port is not specified");
	if(cfg_get_integer(&reconnect_delay, grp, octstr_imm("smsc-reconnect-delay")) == -1)
	{
		warning(0,"smsc-reconnect-delay is not specfied using 10 sec as default");
		reconnect_delay = 10;
	}
	if(cfg_get_integer(&smsc_q_limit, grp, octstr_imm("smsc-unconnect-q-limit")) == -1)
	{
		smsc_q_limit = -1;
	}
	if(cfg_get_integer(&ping_delay,grp,octstr_imm("smsc-ping-delay")) == -1)
		ping_delay = 10;
	if(cfg_get_integer(&ping_ack_timeout,grp,octstr_imm("smsc-pingack-timeout")) == -1)
		ping_ack_timeout = 5;
	forward_client = init_start_client(host,port_num,reconnect_delay,ping_delay,ping_ack_timeout);
	printf("\n\n-------CONNECTING TO FORWARD\n\nn");
	if(forward_client != NULL)
	{
		info(0,"Forward Client successfully initialised thread is :%d",forward_client->thread_id);
		Conn_Msg *msg;
		msg = conn_msg_create(admin);
		msg->admin.command = 1;
		msg->admin.conn_id = octstr_create("smpp-esme-forward");
		forward_client->conn_id = octstr_create("forward-client");
		send_msg_process_client(forward_client,msg);
	}
	else
		panic(0,"Could not connect to forward client");

	reverse_client = init_start_client(host,port_num1,reconnect_delay,ping_delay,ping_ack_timeout);
	if(reverse_client != NULL)
	{
		info(0,"Reverse Client successfully initialised thread is :%d",reverse_client->thread_id);
		Conn_Msg *msg;
		msg = conn_msg_create(admin);
		msg->admin.command = 1;
		msg->admin.conn_id = octstr_create("smpp-esme-reverse");
		reverse_client->conn_id = octstr_create("reverse-client");
		send_msg_process_client(reverse_client,msg);
	}
	else
		panic(0,"Could not connect to reverse client");

	octstr_destroy(host);
	/*
	   log_file = cfg_get(grp, octstr_imm("log-file"));
	   */
	/*
	   if (cfg_get_integer(&lvl, grp, octstr_imm("log-level")) == -1)
	   lvl = 0;
	   */
	/*
	   if(log_file != NULL) 
	   {
	   info(0, "Starting to log to file %s level %ld", octstr_get_cstr(logfile), lvl);

	   new_log_file = logfile_append_time(log_file);

	   log_file_index = log_open(octstr_get_cstr(new_log_file), lvl, GW_NON_EXCL);
	   logfile = octstr_duplicate(new_log_file);
	   octstr_destroy(new_log_file);
	   octstr_destroy(log_file);	

	   log_file = log_file_name(log_file_index);
	//printf("\n\nORIGINAL FILE NAME :%d :%s\n",log_file_index,octstr_get_cstr(logfile));
	octstr_destroy(log_file);	
	}
	*/

	if(cfg_get_integer(&trans_port, grp, octstr_imm("trans-mode-port")) == -1)
		panic(0, "trans-mode-port parameter is MANDATORY");
	if(cfg_get_integer(&recv_port, grp, octstr_imm("recv-mode-port")) == -1)
		panic(0, "recv-mode-port parameter is MANDATORY");
	if(cfg_get_integer(&trans_recv_port, grp, octstr_imm("transrecv-mode-port")) == -1)
		panic(0, "transrecv-mode-port parameter is MANDATORY");
	init_connect_ip(cfg);

	/*
	   init_forward_q_others();
	   init_reverse_q_others();
	   init_system_q_others();
	   init_database_q_others();
	   init_mis_q_others();

	   print_max_q_size();
	   */
	httpadmin_start(cfg);

	gwthread_create(accept_trans_thread, &trans_port);
	gwthread_create(accept_recv_thread, &recv_port);
	gwthread_create(accept_transrecv_thread, &trans_recv_port);
	//gwthread_create(system_thread, NULL);
	date_string = get_log_format_datetime();
	/*Initialise wake up thread ids*/
	if(dbbox_client != NULL && dbbox_client->wakeup_thread_id == -1)
		dbbox_client->wakeup_thread_id = gwthread_self();
	if(forward_client != NULL && forward_client->wakeup_thread_id == -1)
		forward_client->wakeup_thread_id = gwthread_self();
	if(reverse_client != NULL && reverse_client->wakeup_thread_id == -1)
		reverse_client->wakeup_thread_id = gwthread_self();
	while(program_status == PROGRAM_RUNNING)	
	{
		compare_string = get_log_format_datetime();
		if(octstr_compare(date_string,compare_string) != 0)
		{
			octstr_destroy(date_string);
			date_string = octstr_duplicate(compare_string);
			ret  = change_logfile_name(log_file_index);
			if(ret == 0)
			{
				log_name = log_file_name(log_file_index);
				//info(0, "Log file changed successfully:%s",octstr_get_cstr(log_name));
				octstr_destroy(log_name);
			}
			if(access_file_name != NULL)
			{
				Octstr *log_name = NULL;
				log_name = change_access_file_name(access_file_name);
				if(log_name != NULL)
				{
					octstr_destroy(access_file_name);
					access_file_name = octstr_duplicate(log_name);
					octstr_destroy(log_name);
					//info(0, "Access Log file changed successfully:%s",octstr_get_cstr(access_file_name));

				}
			}
			change_esme_logfile(translations);
		}
		//[sanchal][16032009][Code Added for sizewise access-log]
		else
		{
			if( access_file_name != NULL)
			{
				ret = accesslog_file_size( giLogSize, access_file_name);
				// Check the size of file
				// if the file crosses accesslog-file-size limit
				// then create another file by appending -no to
				// the original name
				if( ret == 0)
					//info(0, "Access Log file changed successfully");
					;////printf("\n =========> AccessLog file name changed successfully /n");
			}


			if ((log_file_index != -1) )
			{
				ret = change_logfile_size( log_file_index, giLogSize );
				if( ret == 0)
				{
					log_name = log_file_name(log_file_index);
					//info(0, "Log file changed successfully: %s",octstr_get_cstr(log_name));
					octstr_destroy(log_name);
				}
			}

			change_esme_logfile_onsize(translations, giLogSize);
		}


		octstr_destroy(compare_string);
		/*Handle server disconnections
		  if any of server is disconnected disconnect all ESMEs.
		  */
		if(dbbox_client != NULL && dbbox_client->client_cmd > 0)
		{
			if(dbbox_client->client_cmd == SERVER_CMD_SERVER_DISCONNECTED)
			{
				List *key_list = NULL;
				Octstr *os = NULL;
				Octstr *pdu_os = NULL;
				int i,len;
				error(0,"APPLICATION RECEIVED DBBOX CLIENT DISCONNECT");
				/*remove all the msgs from dict*/
				key_list = dict_keys(pending_deliver_sm);
				len = gwlist_len(key_list);
				for(i = 0 ; i < len ; i++)
				{
					os = gwlist_get(key_list,i);
					if(os == NULL)
						continue;
					error(0,"Dbbox disconnect-dict remove-%s",octstr_get_cstr(os));
					pdu_os = dict_remove(pending_deliver_sm,os);
					octstr_destroy(pdu_os);
				}//for
				gwlist_destroy(key_list,octstr_destroy_item);
			}
			if(dbbox_client->client_cmd == SERVER_CMD_SERVER_CONNECTED)
			{
				info(0,"APPLICATION RECEIVED DBBOX CLIENT CONNECT");
				Conn_Msg *msg;
				msg = conn_msg_create(admin);
				msg->admin.command = 1;
				msg->admin.conn_id = octstr_create("smpp-esme");
				dbbox_client->conn_id = octstr_create("dbbox-client");
				send_msg_process_client(dbbox_client,msg);
				/*dbbox gets connected again sent register message*/
			}
			dbbox_client->client_cmd = SERVER_CMD_UNDEFINED;
		}
		if(forward_client != NULL && forward_client->client_cmd > 0)
		{
			if(forward_client->client_cmd == SERVER_CMD_SERVER_DISCONNECTED)
			{
				error(0,"APPLICATION RECEIVED FORWARD CLIENT DISCONNECT");
				//esme_shutdown(0);
			}
			if(forward_client->client_cmd == SERVER_CMD_SERVER_CONNECTED)
			{
				Conn_Msg *msg;
				msg = conn_msg_create(admin);
				msg->admin.command = 1;
				msg->admin.conn_id = octstr_create("smpp-esme-forward");
				forward_client->conn_id = octstr_create("forward-client");
				send_msg_process_client(forward_client,msg);
				info(0,"APPLICATION RECEIVED FORWARD CONNECT");
			}
			forward_client->client_cmd = SERVER_CMD_UNDEFINED;
		}
		if(reverse_client != NULL && reverse_client->client_cmd > 0)
		{
			if(reverse_client->client_cmd == SERVER_CMD_SERVER_DISCONNECTED)
			{
				error(0,"APPLICATION RECEIVED REVERSE CLIENT DISCONNECT");
				//esme_shutdown(0);
			}
			if(reverse_client->client_cmd == SERVER_CMD_SERVER_CONNECTED)
			{
				Conn_Msg *msg;
				msg = conn_msg_create(admin);
				msg->admin.command = 1;
				msg->admin.conn_id = octstr_create("smpp-esme-reverse");
				reverse_client->conn_id = octstr_create("reverse-client");
				send_msg_process_client(reverse_client,msg);
				info(0,"APPLICATION RECEIVED REVERSE CONNECT");
			}
			reverse_client->client_cmd = SERVER_CMD_UNDEFINED;
		}
		gwthread_sleep(giManagelogInterval);
	}//while
	octstr_destroy(date_string);
	dict_destroy(pending_deliver_sm);
}

void shutdown_smpp_server()
{
	httpadmin_stop();		
}
void handle_request(Conn_Msg *msg,PROCESS_CLIENT *process_client)
{
	static int total_smsc = -1;
	static int smsc_data_recieved = -1;
	if(program_status != PROGRAM_RUNNING)	
	{
		warning(0,"message received when system shutting down :%d",conn_msg_type(msg));
		conn_msg_destroy(msg);
		return;
	}
	/*
	   debug("test.c",0,"[CID:%s]Msg received from IP[%s]PORT[%d]ID[%d]",
	   process_client->conn_id ? octstr_get_cstr(process_client->conn_id):"",        
	   octstr_get_cstr(process_client->client_ip),
	   process_client->client_port,
	   conn_msg_type(msg));
	   */
	if(conn_msg_type(msg) == admin)
	{
		if(msg->admin.command == 1)
		{
			process_client->conn_id = octstr_duplicate(msg->admin.conn_id);
			info(0,"[CID:%s] Registered from [IP%s][PORT%d][CLIENTNUM%d]",
					octstr_get_cstr(process_client->conn_id),
					octstr_get_cstr(process_client->client_ip),
					process_client->client_port,
					process_client->client_num );
		}
		if(msg->admin.command == admin_cmd_dbbox_disconnected)
		{
			dbbox_connected_to_client = 0;
			info(0,"SMSC Process is not connected to dbbox");
			//esme_shutdown(0);
		}
		else if(msg->admin.command == admin_cmd_dbbox_connected)
		{
			dbbox_connected_to_client = 1;
			info(0,"SMSC Process gets connected to dbbox");
		}
	}//admin command
	if(conn_msg_type(msg) == no_of_smsc)
	{
		info(0,"-----------Number of SMSCs connected :%d",msg->no_of_smsc.no_of_smsc);
		total_smsc = msg->no_of_smsc.no_of_smsc;
		smsc_data_recieved = -1;
		/*destroy previous list if any this is cos if smsc process is restarted new smsc info may be sent*/
		smsc_shutdown();	
		smsc_init();
	}
	if(conn_msg_type(msg) == info_smsc)
	{
		/*first time all the smsc data have to be captured to list,
		  after that just update esme connection according to smsc connections*/
		if(smsc_data_recieved < total_smsc-1)
		{
			smsc_data_recieved++;
			debug("smpp-server",0,"SMSC DATA RECEIVED FOR:%d ",smsc_data_recieved);
			debug("smpp-server",0,"ID:%s,Mode:%d,Status:%d,Type:%s ",
					octstr_get_cstr(msg->info_smsc.smsc_id),
					msg->info_smsc.conn_mode,			
					msg->info_smsc.conn_status,
					octstr_get_cstr(msg->info_smsc.smsc_type));
			prepare_smsc_list(msg);
			if(smsc_data_recieved == total_smsc-1)
				display_smsc_info();
			if(smsc_data_recieved == total_smsc-1)
				debug("test",0,"\n\n******GATHERED FULL SMSC INFO :%d***************\n\n",smsc_list_len());
		}
		else
		{
			update_smsc_list(msg);
			update_esme_conn(translations);
			display_smsc_info();

		}
	}//info smsc
	else if(conn_msg_type(msg) == global_q_msg)
	{
		info(0,"RECEIVED GLOBAL Q MSG :%d :%s",msg->global_q_msg.q_limit,
				(msg->global_q_msg.q_limit == 1)?"Q Full":"Q Empty");
		global_q_limit = msg->global_q_msg.q_limit;
	}
	else if(conn_msg_type(msg) == deliver)
	{
		Octstr *key;
		Conn_Msg *msg1;
		Octstr *os;
		/*If we receive deliver sm when dbbox is disconnected discrad the deliver sm
		  but log it in the log file */
		if(dbbox_client->status == PROCESS_CONNECTED)
		{
			os = octstr_duplicate(msg->deliver.pdu);
			key = octstr_format("%s%s",octstr_get_cstr(msg->deliver.smsc_msg_id),octstr_get_cstr(msg->deliver.dest_addr));	
			debug("smpp",0,"-----PUTTING IN DICT :%s",octstr_get_cstr(key));
			dict_put(pending_deliver_sm,key,os);
			octstr_destroy(key);

			msg1 = conn_msg_create(values_get);
			msg1->values_get.smsc_msg_id = octstr_duplicate(msg->deliver.smsc_msg_id);
			msg1->values_get.dest_addr = octstr_duplicate(msg->deliver.dest_addr);
			//send_msg_process_client(dbbox_client,msg1);
			debug("wait_msg_recv.c", 0, "Rerverse Q SMSC_ID:%s:SMSCMSGID:%s:DEST:%s",\
					octstr_get_cstr(msg->deliver.smsc_id),
					octstr_get_cstr(msg->deliver.smsc_msg_id),
					octstr_get_cstr(msg->deliver.dest_addr));			
		}
		else
		{
			error(0,"Received deliver sm when dbbox is not connected. SMSC:%s,SMSCMSGId:%s,Destaddr:%s",
					octstr_get_cstr(msg->deliver.smsc_id),
					octstr_get_cstr(msg->deliver.smsc_msg_id),
					octstr_get_cstr(msg->deliver.dest_addr)
			     );
		}
		//usleep(2);
	}//deliver
	else if(conn_msg_type(msg) == values_got)
	{
		Octstr *key = NULL;
		Octstr *os = NULL;
		int ret;

		/*
		   key = octstr_format("%s%s",octstr_get_cstr(msg->values_got.smsc_msg_id),octstr_get_cstr(msg->values_got.dest_addr));
		   debug("smpp",0,"-----REMOVING FROM DICT :%s",octstr_get_cstr(key));
		   os = dict_remove(pending_deliver_sm,key);
		   printf("---After removing\n");
		//octstr_destroy(key);
		if(os == NULL)
		{
		info(0,"Received message for wrong SMSC id:%s and dest addr:%s :%s",
		octstr_get_cstr(msg->values_got.smsc_msg_id),
		octstr_get_cstr(msg->values_got.dest_addr),
		octstr_get_cstr(key));
		}
		*/
		if(msg->values_got.result == 0)
		{

			info(0,"No account found for SMSC id:%s and dest addr:%s ",
					octstr_get_cstr(msg->values_got.smsc_msg_id),
					octstr_get_cstr(msg->values_got.dest_addr));
			//octstr_destroy(os);
		}
		else if(msg->values_got.result == 1)
		{
			void *rx_str;
			int mode;
			ret = extract_log_idx(msg->values_got.account_name);/*extract log file name cos after that everything will be locked*/
			lock_esme_list();/*This global lock is to take careif esme is destroyed while we are trying to write into the socket */
			rx_str = extract_esme(msg->values_got.account_name,&mode);
			//printf("Mode after extracting esme :%d\n",mode);
			if(rx_str == NULL)
			{
				//printf("Found rx str NULL :%d\n",ret);
				if(ret != -1)
					write_to_logfile(ret,GW_DEBUG,0,"RX ESME DOES NOT EXISTS FOR ACCOUNT NAME: %s AND ID :%s", 
							octstr_get_cstr(msg->values_got.account_name),
							octstr_get_cstr(msg->values_got.account_msg_id));
				else
				{

					info(0, "RX ESME DOES NOT EXISTS FOR ACCOUNT NAME: %s AND ID :%s", 
							octstr_get_cstr(msg->values_got.account_name),
							octstr_get_cstr(msg->values_got.account_msg_id));

				}

				//octstr_destroy(os);				
			}
			else 
			{

				/*
				   printf("----MAKING MESSAGE\n");
				   if(msg->values_got.pdu == NULL)
				   info(0,"values got pdu found NULL");
				   else
				   info(0,"values got pdu found not null");
				   */
				struct msg_deliver *msg_deliver_ptr;
				if(mode == 1 || mode == 2 || mode == 3)
				{
					msg_deliver_ptr = gw_malloc(sizeof(struct msg_deliver));
					msg_deliver_ptr->smsc_id = octstr_duplicate(msg->values_got.dest_addr);
					msg_deliver_ptr->smsc_msg_id = octstr_duplicate(msg->values_got.smsc_msg_id);
					msg_deliver_ptr->account_msg_id = octstr_duplicate(msg->values_got.account_msg_id);
					msg_deliver_ptr->os = octstr_duplicate(msg->values_got.pdu);
				}
				if(mode == 2)
				{
					gwlist_produce(((ESME_RX*)rx_str)->data_to_write,msg_deliver_ptr);
					gwthread_wakeup(((ESME_RX*)rx_str)->thread_id);
				}
				else if( mode == 3 || mode == 1)
				{
					gwlist_produce(((ESME_TX*)rx_str)->data_to_write,msg_deliver_ptr);
					gwthread_wakeup(((ESME_TX*)rx_str)->thread_id);
				}
				else 
				{
					//error(0, "No ESME For writing deliver_sm : %d",mode);
				}
				//octstr_destroy(os);
			}
			unlock_esme_list();
		}		
		octstr_destroy(key);
	}//values got
	conn_msg_destroy(msg);

}

int main(int argc, char **argv)
{

	int http_port;
	double run_time;
	/*Times Update*/
	int cf_index;
	time_t running_time;

	/*Times Update*/

	program_status = PROGRAM_RUNNING;
	gwlib_init();
	process_start_time = time(NULL);

	/*
	   act.sa_handler = handler;
	   sigemptyset(&act.sa_mask);
	   act.sa_flags = 0;
	   sigaction(SIGTERM, &act, NULL);
	   sigaction(SIGINT, &act, NULL);
	   */

	setup_signal_handlers();
	port_for_smsbox = 13001;

	/*  
	    port = 4567;
	    port_for_smsbox = 13001;
	    */

	http_port = 8080;
	smsc_system_id = octstr_create("Fonada SMPP");
	smsc_source_addr = octstr_create("123456");
	message_id_counter = counter_create();
	bearerbox_host = octstr_create("127.0.0.1");

	max_to_esme = 1;
	num_to_esme = counter_create();
	num_from_esme = counter_create();
	num_to_bearerbox = counter_create();
	num_from_bearerbox = counter_create();


	cf_index = get_and_set_debugs(argc, argv, check_args);

	if (argv[cf_index] == NULL)
		config_filename = octstr_create("kannel.conf");
	else
		config_filename = octstr_create(argv[cf_index]);
	cfg = cfg_create(config_filename);

	if(cfg_read(cfg) == -1)
		panic(0, "Couldn't read configuration from `%s'.", octstr_get_cstr(config_filename));

	manage_log(cfg);

	report_versions("smpp_server");

	/*
	   if(log_file != NULL)
	   log_open(log_file, GW_DEBUG, GW_NON_EXCL);
	   */
	info(0, "-----------------------------------------------------");
	info(0, GW_NAME " SMPP-ESME Version %s Starting", GW_VERSION);
	info(0, "-----------------------------------------------------");


	translations = smpp_client_create();
	if(translations == NULL)
		panic(0, "urltrans_create failed");


	if (smpp_client_add_cfg(translations, cfg) == -1)
		panic(0, "urltrans_add_cfg failed");


	if(verify_config_para(translations) == -1)
		panic(0, "Config file verification failed");



	manage_thread(cfg);

	//wait_msg_recv(NULL);/*thread is not required as main thread is already existing*/

	program_status = PROGRAM_DEAD;
	//gwthread_join_all();

	debug("test.smpp", 0, "Program exiting normally.");

	run_time = difftime(last_from_esme, first_to_esme);
	running_time = time(NULL) - process_start_time;
	info(0, "Number of messages sent to ESME: %ld",
			counter_value(num_to_esme));
	info(0, "Number of messages sent to smsbox: %ld",
			counter_value(num_from_bearerbox));
	info(0, "Number of messages sent to bearerbox: %ld",
			counter_value(num_to_bearerbox));
	info(0, "Number of messages sent to SMSC: %ld",
			counter_value(num_from_esme));
	info(0, "Time: %.0f secs", run_time);
	info(0, "Time until all sent to ESME: %.0f secs", 
			difftime(last_to_esme, start_time));
	info(0, "Time from first from bb to last to bb: %.0f secs", 
			difftime(last_to_bb, first_from_bb));
	info(0, "Time until all sent to SMSC: %.0f secs", 
			difftime(last_from_esme, start_time));
	info(0, "SMPP messages SMSC to ESME: %.1f msgs/sec",
			counter_value(num_to_esme) / run_time);
	info(0, "SMPP messages ESME to SMSC: %.1f msgs/sec",
			counter_value(num_from_esme) / run_time);


	info(0, "Uptime for the server Days:%ld,Hour:%ld,Minute:%ld,Seconds:%ld",
			running_time/3600/24, running_time/3600%24, running_time/60%60, running_time%60 );



	shutdown_smpp_server();
	//sanchal][29072009]
	alog ("alog_ends");

	alog_close();
	octstr_destroy(smsc_system_id);
	octstr_destroy(smsc_source_addr);
	octstr_destroy(bearerbox_host);
	counter_destroy(num_to_esme);
	counter_destroy(num_from_esme);
	counter_destroy(num_to_bearerbox);
	counter_destroy(num_from_bearerbox);
	counter_destroy(message_id_counter);
	octstr_destroy(config_filename);
	cfg_destroy(cfg);
	octstr_destroy(logfile);
	octstr_destroy(access_file_name);
	/*
	   delete_msgq(DELETE_FORWARD_QUEUE);
	   delete_msgq(DELETE_SYSTEM_QUEUE);
	   */
	gwlib_shutdown();

	return 0;
}
/*HTTP Admin related functions.....*/

Octstr *print_server_status(int status_type)
{
	Octstr *tmp;
	time_t running_time;
	running_time = time(NULL) - process_start_time;
	Octstr *log_name;
	log_name = log_file_name(log_file_index);

	Octstr *dbbox_connected,*dbbox_ip,*dbbox_name;
	long dbbox_port=0,dbbox_msg_sent=0,dbbox_msg_recv=0,dbbox_online=0,dbbox_queue = 0;

	Octstr *forward_ip,*forward_name,*forward_connected;
	long forward_port = 0,forward_msg_sent=0,forward_online=0,forward_queue = 0 ;

	Octstr *reverse_ip,*reverse_name,*reverse_connected;
	long reverse_port=0,reverse_msg_recv=0,reverse_msg_sent=0,reverse_online=0,reverse_queue = 0;

	if(dbbox_client != NULL && dbbox_client->status == PROCESS_CONNECTED)
		dbbox_connected = octstr_create("Connected");
	else
		dbbox_connected = octstr_create("Disconnected");
	if(dbbox_client != NULL && dbbox_client->status == PROCESS_CONNECTED)
	{
		dbbox_ip = octstr_duplicate(dbbox_client->client_ip);
		dbbox_port = dbbox_client->client_port;
		dbbox_online = time(NULL) - dbbox_client->online_time;
		dbbox_msg_sent = dbbox_client->req_sent;
		dbbox_msg_recv = dbbox_client->req_recv;
		dbbox_queue = gwlist_len(dbbox_client->send_list);
		dbbox_name = dbbox_client->conn_id ? octstr_duplicate(dbbox_client->conn_id):octstr_create("");
	}
	else
	{
		dbbox_ip = octstr_create("");
		dbbox_msg_sent = dbbox_client->req_sent;
		dbbox_msg_recv = dbbox_client->req_recv;
		dbbox_queue = gwlist_len(dbbox_client->send_list);
		dbbox_name = dbbox_client->conn_id ? octstr_duplicate(dbbox_client->conn_id):octstr_create("");
	}

	if(forward_client != NULL && forward_client->status == PROCESS_CONNECTED)
		forward_connected = octstr_create("Connected");
	else
		forward_connected = octstr_create("Disconnected");

	//printf("\n>>>>>>>>>>>forward status:%d\n\n",forward_client->status);
	if(forward_client != NULL && forward_client->status == PROCESS_CONNECTED)
	{
		forward_ip = octstr_duplicate(forward_client->client_ip);
		forward_port = forward_client->client_port;
		forward_online = time(NULL) - forward_client->online_time;
		forward_msg_sent = forward_client->req_sent;
		forward_queue = gwlist_len(forward_client->send_list);
		forward_name = forward_client->conn_id ? octstr_duplicate(forward_client->conn_id):octstr_create("");
	}
	else
	{
		forward_ip = octstr_create("");
		forward_msg_sent = forward_client->req_sent;
		forward_queue = gwlist_len(forward_client->send_list);
		forward_name = forward_client->conn_id ? octstr_duplicate(forward_client->conn_id):octstr_create("");
	}


	if(reverse_client != NULL && reverse_client->status == PROCESS_CONNECTED)
		reverse_connected = octstr_create("Connected");
	else
		reverse_connected = octstr_create("Disconnected");
	if(reverse_client != NULL && reverse_client->status == PROCESS_CONNECTED)
	{
		reverse_ip = octstr_duplicate(reverse_client->client_ip);
		reverse_port = reverse_client->client_port;
		reverse_online = time(NULL) - reverse_client->online_time;
		reverse_msg_sent = reverse_client->req_sent;
		reverse_msg_recv = reverse_client->req_recv;
		reverse_queue = gwlist_len(reverse_client->send_list);
		reverse_name = reverse_client->conn_id ? octstr_duplicate(reverse_client->conn_id):octstr_create("");
	}
	else
	{
		reverse_ip = octstr_create("");
		reverse_msg_sent = reverse_client->req_sent;
		reverse_msg_recv = reverse_client->req_recv;
		reverse_queue = gwlist_len(reverse_client->send_list);
		reverse_name = reverse_client->conn_id ? octstr_duplicate(reverse_client->conn_id):octstr_create("");
	}

	tmp = octstr_format("Server Process ID: %d.										"
			"%sServer Process Status: %s								"
			"%sOnline Time: Days:%ld,Hour:%ld,Minute:%ld,Seconds:%ld	"
			"%sNumber of connected ESME :%d								"
			"%sNumber of connected SMSC :%d								"
			"%sConfiguration File path : %s								"
			"%sLog File path : %s										"
			"%sDict Count :%ld											"
			"%sDbbox server[IP:%s][Port:%d]:%s,ID:%s,Msgsent:%ld,Msgrecv:%ld,MsgQ:%ld,Online Days:%ld,Hour:%ld,Min:%ld,Sec:%ld"	
			"%sForward server[IP:%s][Port:%d]:%s,ID:%s,Msgsent:%ld,MsgQ:%ld,Online Days:%ld,Hour:%ld,Min:%ld,Sec:%ld"
			"%sReverse server[IP:%s][Port:%d]:%s,ID:%s,Msgsent:%ld,Msgrecv:%ld,MsgQ:%ld,Online Days:%ld,Hour:%ld,Min:%ld,Sec:%ld"
			,
			(int)getpid(),
			bb_status_linebreak(status_type),get_server_status_name(program_status),
			bb_status_linebreak(status_type),running_time/3600/24, running_time/3600%24, running_time/60%60, running_time%60,
			bb_status_linebreak(status_type),esme_list_len(),
			bb_status_linebreak(status_type),connected_smsc_list_len(),
			bb_status_linebreak(status_type),octstr_get_cstr(config_filename),
			bb_status_linebreak(status_type),octstr_get_cstr(log_name),
			bb_status_linebreak(status_type),dict_key_count(pending_deliver_sm),
			bb_status_linebreak(status_type),octstr_get_cstr(dbbox_ip),dbbox_port,octstr_get_cstr(dbbox_connected
				),octstr_get_cstr(dbbox_name),dbbox_msg_sent,dbbox_msg_recv,dbbox_queue,dbbox_online/3600/24,dbbox_online/3600%24,dbbox_online/60%60,dbbox_online%60,

			bb_status_linebreak(status_type),octstr_get_cstr(forward_ip),forward_port,octstr_get_cstr(forward_connected),octstr_get_cstr(forward_name),forward_msg_sent,forward_queue,forward_online/3600/24,forward_online/3600%24,forward_online/60%60,forward_online%60,

			bb_status_linebreak(status_type),octstr_get_cstr(reverse_ip),reverse_port,octstr_get_cstr(reverse_connected),octstr_get_cstr(reverse_name),reverse_msg_sent,reverse_msg_recv,reverse_queue,reverse_online/3600/24,reverse_online/3600%24,reverse_online/60%60,reverse_online%60

				);

	octstr_destroy(log_name);
	octstr_destroy(dbbox_connected);
	octstr_destroy(dbbox_ip);
	octstr_destroy(dbbox_name);
	octstr_destroy(forward_connected);
	octstr_destroy(forward_ip);
	octstr_destroy(reverse_connected);
	octstr_destroy(reverse_ip);
	octstr_destroy(reverse_name);
	octstr_destroy(forward_name);

	return tmp;
}



void smpp_server_shutdown()
{
	pid_t process_thread_id;
	info(0, "SERVER SYSTEM SHOULD BE SHUTDOWN BY HTTP ADMIN COMMAND");
	program_status = PROGRAM_SHUTDOWN; 
	process_thread_id = getpid();
	kill(process_thread_id,SIGINT);
}

Octstr *server_print_status_configured_esme(int status_type)
{
	Octstr *tmp;
	tmp = print_status_configured_esme(status_type,translations);
	return tmp;
}
